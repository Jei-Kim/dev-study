# chapter 06. 입출력과 네트워킹

- 프로그래밍 관점에서 I/O 장치와 상호작용하는 기술에 집중
- 실제 세계의 아날로그 데이터를 컴퓨터가 사용가능한 디지털로 바꾸거나, 역방향으로 바꾸기 위해서는 샘플링 필요



## 저수준 I/O


- CPU가 읽거나 쓸 수 있는 비트에 물건을 연결한 것

* I/O 포트

    - 예시: AVR PORT 레지스터
        - DDRB(데이터 방향 레지스터): 각 핀의 입력(0)/출력(1) 담당을 결정
        - PORTB: 출력 데이터를 저장하는 래치
        - PINB: 핀의 값 읽음

* 버튼을 눌러라

    - 푸쉬 버튼은 두 접점, 두 접점을 연결하는 금속 조각으로 구성
        - 버튼을 누르고 땔 때 튕겨지면서 바운스 발생할 수 있음 -> 디바운스 위해 타이머 설정
            => 물리적인 방법보다는 소프트웨어로 구현(유한 임펄스 응답 필터)

* 빛이 있으라

    - 가장 흔한 유형의 표시 장치는 세그먼트 디스플레이
        - LED와 연결 핀으로 구성
        - 공통 연결핀을 사용하는 '공통 캐소드' 디스플레이로 비용 절약
        - 제어하기 위한 소프트웨어에는 숫자와 그에 따라 어떤 led를 연결할 지 연관시켜주는 표로 구성됨
        - 보통 디스플레이는 여러 개 사용 -> 멀티플렉스 사용

    - LED의 D는 다이오드를 뜻함 -> 다이오드는 전류를 한쪽으로 통과시킴
    
    - 시각의 잔상효과를 이용해 짧은 간격으로 세그먼트를 켰다 껐다해서 세그먼트가 계속 켜져 있게 보이도록 함

* 빛, 동작, 그리고 상호 연동

    - 버튼과 디스플레이가 함께 있는 장치의 경우, 버튼과 디스플레이의 입력을 멀티플렉싱 -> 핀 절약

* 밝기 조절

    - 듀티 사이클을 조절함 -> 밝기 조절
    - 밝기는 디스플레이가 켜져 있는 시간과 연관

* 그레이의 2^n가지 그림자

    - 회전축의 위치를 알아내야 하는 경우, 축의 위치를 2진수 인코딩해야 함

    * 그레이 코드
        - 기존 인코더의 전파 지연 문제점 보완 -> 각도가 달라질 때 비트가 하나씩만 달라지는 인코딩 방법

* 쿼드러처

    - 그레이 코드를 이용해 어떤 대상의 위치 변동 여부와 방향을 알 수 있음
        - 변형에는 4가지 형태 존재 -> 쿼드러처 인코딩

    - 2비트 그레이 코드 패턴 여러 번 반복됨
    - 현재 위치와 이전 위치로부터 4비트 숫자 생성 -> 회전축의 회전방향을 알 수 있음

    - 쿼드러처 인코더를 서로 90도로 엇갈려 놓고 가운데 고무 공을 넣으면 -> 마우스

* 병렬 통신

- 병렬: LED컴포넌트 하나하나에 별도의 선 존재, 동시에 모든 컴포넌트 제어 가능

    * IEEE 1284 병렬 포트
    - 아스키 문자 전송을 위한 8개의 데이터 선 존재
    - USB(일반 직렬 버스)등장 이전, 프린터 및 스캐너에 사용됨
    - 스트로브: 타이밍을 알려줌

    * IDE
    - 과거 디스크 드라이브와 통신 시 사용

    - 병렬 인터페이스는 가격이 비싸다는 단점이 있음

    * 직렬 통신

    - 통신 거리가 멀어짐에 따라 전체 비용 증가 -> 직렬 통신 필요
    - 송신하는 쪽에서 스트로브 신호가 각 비트를 한 위치씩 시프트하며 밀려 나가는 비트를 선을 통해 내보냄
    - 수신하는 쪽에서는 클록이 비트를 한 이치씩 시프트 -> 빈 자리에 선을 통해 받은 비트를 채워 넣음
    - 송신자와 수신자가 동기화되어야 함

        * 텔레타이프에 사용

        - 전송할 데이터는 직렬 프로토콜을 통해 전달, 돌아오는 선 별도로 필요
            - 마크-스페이스 신호
            - 마크는 하이, 스페이스는 로우를 뜻함
    
        * 시간 분할 멀티플렉싱
        : 시간을 나눈 슬롯마다 각기 다른 비트를 할당, 데이터를 한 선에 멀티플렉싱
        - 초당 비트 수 : 보 레이트라 불림(정확히 같지는 않음)

    * 반이중 통신
    - 송신자와 수신자가 같은 선을 공유
        - 동시에 이야기할 경우 충돌 발생 x
        - (ex. 무전기)

    * 전이중 통신
    - 선이 두 개로 각기 다른 방향으로 동시에 통신이 가능한 경우
    - 이러한 통신을 가능하게 해주는 회로가 하나의 IC로 만들어짐 -> UART(범용 비동기 수신기-송신기)
        - 소프트웨어로 UART를 구현하는 경우 -> 비트 뱅잉

    - 기타 직렬 인터페이스: SPI, I2C, TWI, 원와이어


* 파동에 올라타라

- 다양한 파장 존재, 가장 근본은 사인파 -> 다른 모든 파형은 사인파의 조합

    * 용어 정리

    - 진폭: 사인파의 높이
    - 주파수: 매초 같은 방향으로 0을 지나치는 횟수 = 헤르츠(Hz), 초당 사이클
    - 파장: 같은 방향으로 0을 지나는 연속된 두 지점 사이의 거리

    - 모뎀: 변조와 복조를 수행하는 장치
        - 변조: 전달하려는 신호를 바탕으로, 반송파를 마크-스페이스 파형으로 변조해서 보냄
        - 복조: 음향을 다시 마크와 스페이스로 되돌림

* 범용 직렬 버스
    - USB
    - 구조화된 데이터 전송
    - 종단점을 담당하는 컨트롤러, 데이터를 담는 패킷(헤더, 페이로드) 등

    - 음향과 비디오를 등시성 전송을 통해 처리 가능
    - 종단점은 데이터 전송을 보장하기 위해 원하는 대역폭 요청 가능
        - 충분한 대역폭이 없는 경우 컨트롤러는 이를 거부할 수 있음



## 네트워킹

- 네트워크는 두 가지로 구분
    - 근거리 네트워크(LAN)
    - 광역 네트워크(WAN)

- 최초의 네트워크: 전신 네트워크 -> 이후 전화 네트워크로 발전
- 전화 네트워크
    - 회선 교환 방식 -> 패킷 교환 방식으로 발전

- ARPA는 패킷 스위치 방식의 WAN인 아파넷 지원 -> 아파넷은 이후 인터넷으로 발전

* 인터넷
    - 네트워크와 네트워크의 사이
    - 네트워크들로 이루어진 네트워크
    - 여러 LAN을 하나로 연결해주는 WAN

* 최근의 LAN들

    * 이더넷

        - 반이중 시스템: 모든 장치가 같은 선에 연결됨

        - 각 장치의 네트워크 인터페이스에 MAC 주소(유일한 48비트 주소) 부여

        - 데이터는 1,500 바이트 가량의 '프레임'이라는 패킷으로 구성됨
            - 프레임에는 송신 주소, 수신 주소, 오류 검증이 포함된 헤더와 페이로드가 함께 들어감

        - 모든 장치가 동시에 이야기 -> 패킷 충돌 발생
            - 랜덤 백오프 후 재시도: 충돌 발생 시 임의의 시간 기다림 후 다시 시도

        - 현재도 여전히 이더넷이 쓰이지만, 반이중 버전은 아님
            - 각 장치가 라우터에 연결되어, 라우터는 어떤 장치가 어떤 선에 연결되어 있는지를 기억하고 패킷을 정확히 전달함

    * 인터넷

        - 물리적인 네트워크 X -> 여러 계층으로 이루어진 프로토콜의 집합
        - 물리적 네트워크(아래쪽 계층)을 변경해도 위쪽 계층에 영향이 없도록 설계


        * TCP / IP

            - 전송 제어 프로토콜 / 인터넷 프로토콜
            - 인터넷이 사용하는 두 가지 프로토콜
            - IP는 패킷(데이터그램)을 다른 곳으로 옮겨 줌 -> 송신자는 수신자의 수신 여부와 시점을 알 수 없음
                - TCP는 IP위에 만들어짐 -> 패킷이 배달되었는지 보장함


        * IP 주소

            - 인터넷상의 각 컴퓨터에는 유일한 IP 주소 존재
                - (맥 주소와 달리 하드웨어에 묶여있지 않아, 변경될 수 있음)

            - 대부분 IPv4에서 이루어짐
                -  32비트 주소 사용, 옥탯(xxx.xxx.xxx.xxx) 표기

            - 할당할 주소가 부족해짐에 따라, IPv6로 나아가는 중


        * 도메인 이름 시스템

        - 장치의 IP주소가 변경되었을 때, 실제 주소를 찾는 방법? -> 도메인 이름 시스템(DNS)
            - 전화번호부에 비유
            - 이름을 주소로 바꾸어 알려줌


        * 월드 와이드 웹
        
        - TCP/IP 위에 만들어진 여러 프로토콜 존재

            - SMTP: 전자우편 시스템 작동 기반 프로토콜

            - HTTP: 하이퍼텍스트 전송 프로토콜 
                - HTTPS와 함께 웹 페이지 전송을 책임짐

        - HTTP 표준은 웹 브라우저가 웹 서버와 상호작용하는 방법을 정의 
            - 웹 브라우저: 웹 페이지를 볼 때 사용하는 프로그램
            - 웹 서버: 요청한 페이지를 제공

        - URL(Uniform Resource Locator) 웹사이트 주소에 따라 웹 페이지를 얻을 수 있음

        - URL에는 인터넷상의 컴퓨터에 대한 도메인 이름과, 이 컴퓨터 안의 어디에서 정보를 찾아야 할지에 대한 설명이 들어감

        - 웹 페이지는 보통 HTML로서 존재, 웹에서 가장 많이 쓰이는 언어 --> 9장에서 자세히 다룸



## 아날로그 처리 방법

- 아날로그는 연속적이지만 컴퓨터에서는 연속적인 대상을 저장할 방법이 없음 -> 데이터의 샘플을 취하는 '샘플링 필요'
    - 아날로그를 디지털로 저장 후, 다시 영상이나 빛으로 보여주기 위해서는 샘플링 데이터로부터 아날로그 신호를 만들어야 함

* 디지털을 아날로그로 변환

    - DA 변환기 사용
        - 전압을 만들어 냄, 해상도란 DAC가 만들어내는 단계 수 표현

        - 아날로그 파형을 만들어 오디오 플레이어 등 작동시킴
            - 복잡한 파형을 만들기 위해서는 추가 회로를 통해 메모리에 있는 데이터를 읽어야함
            - 데이터를 일정한 비율로 처리하기 위해 FIFO설정으로 구현

                - 높은 워터마크와 낮은 워터마크의 두 가지 트리거를 이용, 각각에 도달할 때 펌프를 온/오프하는 원리로 작동

* 아날로그를 디지털로 변환

    - AD 변환기 사용
        - DA보다 복잡 -> 아날로그 신호를 흔들리지 않게 잡아내기 위해서

        - 샘플 앤드 홀드 회로로 아날로그 파형의 값을 잡아 냄
            - 래치의 아날로그 방식이라고 이해

        - 문턱값과 신호를 비교해주는 '비교기'회로 존재

        - 비교기를 여러 기준 전압과 연결해 쌓으면 '플래시 변환기'
            - 결과값을 빠르게 만들어내기 때문에 플래시 변환기라고 불림

            - 더 효율적이고 경제적인 AD 변환기를 만들기 위해 고정된 몇 가지의 기준 전압 대신, 
                비교기를 하나만 사용하고 기준 전압을 변화시키는 방법 사용하는 방법 고안 -> DAC로부터 기준 전압 얻기
                - -> 램프 변환기
                - 연속 추정 변환기: 우회 방식 사용, 하드웨어로 2진 검색 진행

* 디지털 오디오

    - 샘플링을 하면 오디오를 디지털화할 수 있음 
        - -> 일정 시간 간격으로 신호의 진폭, 높이 측정

    - 여러 음이 모여 이루는 '코드'는 푸리에 변환을 통해 각 부분을 구분할 수 있음
        - 주파수와 진폭의 관계로 파형을 분석
        - -> 더 빠른 푸리에 변환 알고리즘, 해먼드 B-3 오르간 등 응용
        
    - 그래픽 이퀄라이저: 조절 가능한 필터의 집합
        - 필터: 정해진 주파수를 통과시키거나 막는 장치
            - 로우패스 필터(어떤 주파수보다 낮은 주파수 통과)
            - 하이패스 필터(어떤 주파수보다 높은 주파수 통과)
            - 밴드패스 필터(최저 주파수와 최고 주파수 사이의 주파수를 제외한 나머지를 모두 무시, 로우패스와 하이패스의 조합)
            - 노치(특정 주파수만 제외시킴, 로우패스와 하이패스의 조합)

    - 높은 주파수를 써서 샘플링해야 하는 이유
        - 위상차(왼쪽과 오른쪽 구에 도달하는 신호 사이의 시간차로 인해 생기는 차이)때문

    - 오디오에는 많은 데이터가 들어 있음 -> 데이터를 압축해서 공간을 적게 차지하게 하는 것이 중요
        - 압축 필요
            - 무손실 압축: 원래 데이터를 그대로 유지, 데이터 크기를 절반 크기로 줄임
                - FLAC(무료 무손실 오디오 코덱)

            - 손실 압축: 일부 세부사항이 사라짐(사람이 듣지 못하는 소리 제거)
                - MP3, AAC, Ogg

            - ****코덱이란, 코더-디코더의 줄임말, 모뎀과 비슷하게 어떤 대상을 한 코딩 시스템에서 다른 코딩 시스템으로 변환해주는 장치를 뜻함*
            

* 디지털 이미지

    - 시각 이미지는 2차원 공간을 샘플링해야 함 -> 오디오보다 복잡함
    - 그림 요소 또는 픽셀로 이뤄진 직사각형의 배열로 표현됨

    - 컴퓨터는 가산 혼합 색 시스템을 사용해 색 표현(빨,파,초 이용)
        - 인쇄에는 감산 시스템이 쓰임(청록색,자홍색,노란색을 원색으로 사용)

    - 이미지 샘플링 작업에는 포인트 샘플링 작업이 필요
        - 포인트 샘플링: 정사각형 전체의 색이 아닌, 정사각형 중심 점의 색을 기록
        - 슈퍼 샘플링: 한 정사각형 안에서 여러 지점의 색을 얻어 평균을 기록

    - 가장 일반적인 이미지 압축 방법은 JPEG

* 비디오

    - 움직임 보상: 프레임이 변할 때 변경된 영역의 데이터만 저장하는 기법
        - 데이터 왜곡되는 문제점 발생할 수 있음(화면이 블록 단위로 깨지는 현상)
            - 데이터 복구 방법 고안: 정기적으로 데이터에 키프레임 추가

        - MPEG4 등 새 압축 표준은 레이어링(레이어 간 각기 다른 그림을 중첩해 비디오 이미지를 만들어 냄) 지원



## 휴먼 인터페이스 장치

* 터미널


* 그래픽 터미널


* 벡터 그래픽


* 래스터 그래픽


* 키보드와 마우스


## 정리

