# chapter 05. 컴퓨터 아키텍처와 운영체제

- 컴퓨터 아키텍처란 컴퓨터의 여러 구성요소를 배치하는 방법을 뜻함
- 5장에서는 주로 메모리와 관련한 구조 개선을 다룸



## 기본적인 구조 요소들


- 가장 흔한 컴퓨터 구조는 폰 노이만과 하버드 구조임. 메모리 배열의 차이

* 프로세서 코어

- cpu 성능을 향상하기 위한 방법이 계속 등장
    - 멀티프로세서, 병렬화

- 전력장벽(회로를 이루는 물질의 과열)으로 회로를 소형화, 고성능화하기 어려워짐

- 작아진 회로 크기를 활용하는 방법 등장
    - cpu라 불리던 것이 프로세스 코어로 불리기 시작
    - 여러 개의 프로세서 코어인 멀티코어가 일반화 됨

* 마이크로프로세서와 마이크로컴퓨터

    * 마이크로프로세서
        : 메모리와 I/O가 프로세서코어와 같은 패키지에 들어 있지 않음
        - 보통 큰 시스템의 부품으로 쓰임

    * 마이크로컴퓨터
        : 메모리와 I/O가 프로세서코어와 같은 패키지에 들어 있음, 모든 요소를 하나의 칩에 패키징
        - 식세기 등 단일 칩으로 된 작은 컴퓨터
        - 아두이노(마이크로컴퓨터 칩 기반 하버드 구조의 컴퓨터)

    * 단일 칩 시스템(SoC)
        : 변형, 더 복잡한 마이크로컴퓨터를 뜻함
        - 핸드폰
        - 커스텀화 가능한 EPGA(field programmable gate array)를 제공하기도 함
        


## 프로시저, 서브루틴, 함수


- 함수(=프로시저, 서브루틴)은 코드를 재사용하는 주요 수단
- 프로그래밍 언어에 따라 각각의 용어로 다르게 불림

- 코드 예시: 함수를 호출함으로써 같은 코드를 여러 번 작성하지 않아도 결과 출력 가능
    - 함수로 들어간 위치는 프로그램 카운터의 값
    - 명령어 집합을 활용해 함수 호출
        - 함수에서 돌아오는(리턴) 주소를 계산하기 위해 명령어 사용
        - 함수 안의 코드를 실행하면, 간접 분기
        - 반환 주소에 결과 저장?

- ARM 프로세서는 '링크 레지스터를 사용해 분기' 명령어가 존재
    - = 함수로 호출하는 명령어 + 현재 명령어의 다음 위치를 저장하는 명령어



## 스택


- 함수가 위의 과정처럼 항상 단순한 코드로 이루어지지는 않음. 다른 함수를 호출하거나, 자기자신을 호출하는 경우 O

* 재귀(recursion)
    - 함수가 자기 자신 호출
        - 예) JPEG 압축 시 재귀적 분할을 사용한 압축
            - 네 부분으로 나누고 각 부분을 검사 -> 1픽셀짜리 조각이 생길때까지 반복
    - subdivide 예시

* tree 구조
- 유향 비순환 그래프
- 화살표를 따라 가며 읽음

- 화살표가 뻗어나가지 않는 부분을 잎 노드(leaf node), 뿌리 부분을 root라 부름
- 루트에서 아래쪽으로 뻗어나가는 모양

- 각 노드에서 가지가 4개 뻗어나가는 구조 = 쿼드트리
    - 공간데이터 구조에 속함

- 재귀 함수가 제대로 작동하기 위해서는?
    - 반환 주소를 여러 개 저장할 수 있어야 함
    - 함수에서 호출 지점으로 반환할 때 (여러개의 저장된 주소 중) 어떤 주소를 사용할지 알아야 함

    * 깊이 우선 순회
        - 항상 아래로 가다가, 더 이상 내려갈 곳이 없으면 옆 화살표로 넘어감

    * 너비 우선 순회
        - 항상 옆으로 가다가, 옆 화살표가 없으면 아래 화살표로 넘어감

    - 트리에서 한 수준을 내려갈 때마다 돌아올 위치 기억해야 함
    - 원래 위치로 돌아오고 나면, 저장한 위치는 더 이상 필요하지 않음

* 스택

    - 반환 주소를 저장하기 위해 필요한 것은 접시 더미 같은 역할을 할 수 있는 장치
        - = 스택
        - LIFO 구조 (last in, first out)
        - push & pop
        - 스택 오버플로 = 스택에 더 이상 들어갈 공간이 없는 것
        - 스택 언더플로 = 빈 스택에서 물건을 가져오려고 하는 경우

    - 대부분의 컴퓨터 하드웨어는 스택을 지원
    - 스택 오버플로를 항상 검사하지 않아도 되는 '한계 레지스터'가 포함되어 있음
    - 소프트웨어가 이런 제한을 넘어갈 경우, 예외 발생

    - 단순히 반환 주소만 저장하는 것을 넘어
    - subdivide 함수는 속도 향상을 위해 이미지의 절반 크기를 계산 -> 지역 변수에 저장 -> 여덟 번 사용
    - 함수가 호출될 때마다 저장되는 데이터의 모음 = '스택 프레임'

    - 포스, 포스트스크립트 언어는 스택 기반



## 인터럽트


- 순서도: 작업이 이뤄지는 순서를 표현하는 다이어그램
    - 두 가지 이상의 작업을 해야 할 경우 순서도?
        - 폴링: 하나의 작업을 최소 단위로 나누고, 작은 단위의 과정 사이에 들어 온 또 다른 작업 수행
        - -> 한계 o
        - -> 실행중인 작업을 잠시 중단할 필요 o -> 인터럽트 시스템

    * 인터럽트 시스템

    - 적절한 신호가 들어오면 cpu 실행을 잠시 중단시킬 수 있는 핀 또는 전기 연결
        - 핀: 칩에 연결된 전기적 접점
        - 칩에는 핀 외에도 통합 주변장치 등 다른 부품도 쓰임

    * 인터럽트 시스템 작동 방식

        - 인터럽트 요청 생성
        - 인터럽트 핸들러(작업 1 멈춤, 작업 2 실행 -> 작업 2 완료, 작업 1 재실행)
    
    * 고려해야 할 요소

    - 응답 시간
    : 인터럽트 처리를 정해진 시간 안에 끝내야 함

    - 현재 상태 저장
    : 인터럽트를 서비스하고 나중에 원래대로 돌아오기 위함
    (ex. 인터럽트 핸들러는 레지스터를 저장했다가 복구해주어야 함)

    - 인터럽트 시스템은 서비스 후 돌아올 프로그램 위치를 스택에 저장함
        - 시간 소모 최소화

    - 인터럽트 핸들러 위치?
        - 핸들러 주소를 저장할 메모리 내 인터럽트 벡터에 핸들러 주소 저장
        - 인터럽트 벡터란, 메모리 위치를 가리키는 포인터

    * 인터럽트 제어

    - 마스크: ~하는 동안 인터럽트하지 말라는 제어

    - 우선순위: 더 중요한 인터럽트 먼저 처리
        - -> 우선순위가 낮은 인터럽트를 서비스하는 핸들러는, 우선순위가 높은 인터럽트가 발생하면 잠시 중단될 수 있음

    - 타이머: 일정 시간이 지나면 인터럽트 발생시킬 수 있는 내장 장치

- 운영체제는 일반 프로그램들은 접근할 수 없는 물리적 인터럽트에 접근할 수 있는 경우 존재
- 운영체제는 가상의 인터럽트나 소프트웨어 인터럽트 시스템을 제공하기도 함
    - 유닉스 '시그널'
    - '이벤트'



## 상대 주소 지정


- 여러 프로그램 실행 시, 각 프로그램을 전환시켜 줄 수 있는 관리자 프로그램을 '운영체제' 혹은 '운영체제 커널'이라 함
- 운영체제(OS) = 시스템 프로그렘
- 이 외 모든 프로그램 = 사용자 프로그램, 프로세스

* 시분할
    - 사용자 프로그램의 실행 시간을 조절하는 스케줄링 방법
    - OS는 타이머를 통해 사용자 프로그램을 전환시킬 때를 판단

* 프로그램 상태 (문맥)
    - 컨텍스트라 불림
    - 레지스터 상태와 사용자 프로그램이 사용중인 메모리의 상태(스택 포함)

- 사용자 프로그램을 하나씩 메모리에 올리는 방법 사용 -> 속도 향상
    - 절대 주소 지정(명령어가 특정 메모리의 주소 가리킴)으로 프로그램 실행 오류

        - -> 해결법1: 인덱스 레지스터 추가
            - 인덱스 레지스터 값 + 절대 주소 값 = 유효 주소 값 계산

        - -> 해결법2: 상대 주소 지정
            - 프로그램을 메모리의 원하는 위치로 재배치



## 메모리 관리 장치

- 모든 것이 인터넷과 연결됨 -> 통신 작업은 백그라운드에 실행되어야 함 -> 멀티태스킹 필수
    - 인덱스 레지스터와 상대주소지정 외 추가 조건 필요

* 메모리 관리 장치(MMU)
    - 현재 대부분의 마이크로프로세서에 내장
    - 다른 프로그램의 버그나 메모리를 덮어 쓰지 않도록, 각 프로그램을 분리
    - 가상 주소와 물리 주소를 구분

    * MMU 주소 변환
    - 프로그램은 가상 주소를 사용해 작성, MMU는 가상 주소를 물리 주소로 변환해 메모리에 전달

    *  페이지 테이블
    - 가상 메모리 주소의 상위 부분, 주소를 변환하는 영역
    - 페이지와 페이지 경계

    * 공유 메모리
    - 여러 프로그램의 가상 메모리 중 일부가 같은 물리 메모리를 함께 사용

    * 제어 비트
    - 실행 불가 비트
        : 페이지에 실행 불가 비트가 있으면, cpu가 해당 페이지의 명령어 실행 불가
        - 프로그램이 자기 데이터를 실행하는 경우 방지
    - 읽기 전용 비트

    * 페이지 폴트 예외
    - 프로그램이 물리적 메모리에 연관되지 않은 주소에 접근 시 발생
    - 스택 오버플로 발생 시, 스택 범위를 벗어나는 주소에 접근 -> 페이지 폴트 발생
        - 실행중인 프로그램 중단 대신 MMU가 추가 메모리를 할당하게 해서 스택 공간을 늘리고, 사용자 프로그램 실행을 계속함

- MMU로 인해 폰 노이만 구조 / 하버드 구조의 구분이 의미 없어짐
    - 단일 메모리 버스를 사용하는 폰 노이만 구조도 메모리를 분리해서 제공할 수 있어졌기 때문


## 가상 메모리


* 요구불 페이징
    - 요청받은 메모리가 물리적 메모리의 크기보다 큰 경우
        1. OS는 현재 필요하지 않은 메모리 페이지를 디스크로 옮기고(스왑 아웃)
        2. 스왑 아웃한 페이지에 프로그램 접근 -> 필요한 메모리 공간 확보
        3. 요청받은 페이지를 다시 메모리로 불러들임(스왑 인)

    - 스와핑(스왑아웃,스왑인) 발생 시 시스템 성능 저하
        - -> 성능 저하를 막기 위해 페이지 접근을 추적해 스왑아웃할 페이지를 결정하는 '최소 최근 사용(LRU)' 알고리즘 등 사용



## 시스템 공간과 사용자 공간


- CPU에는 컴퓨터가 시스템 모드인지 사용자 모드인지 결정하는 비트가 들어 있음

- I/O 처리 등 일부 명령어 = 특권 명령어 = 시스템 모드에서만 실행 가능
    - 트랩, 시스템 콜이라는 명령어를 통해 사용자 모드에서 실행 중인 프로그램이 시스템 모드 프로그램에게 요청을 보낼 수 있음



## 메모리 계층과 성능


* 메모리 계층
    (위: 빠르고 비쌈, 아래: 느리고 쌈)

    - CPU
    - 레지스터
    - L1 캐시
    - L2 캐시
    - L3 캐시
    - 주 메모리
    - 대량 저장장치

- CPU 속도 향상을 메모리 속도가 따라가지 못함 -> 갭을 해결하기 위한 방법 등장

    - CPU에 캐시 하드웨어(프로세서와 같은 속도로 동작) 추가
        - CPU 메모리 컨트롤러 하드웨어는 메모리에서 연속된 열에 있는 데이터를 한 번에 가져 옴
        - 캐시 실패: 어떤 내용을 찾았는데 캐시에 없어서 메모리에서 읽어와야 하는 경우
        - 캐시 적중: CPU가 원핳는 내용을 캐시에서 찾은 경우
        - 캐시 메모리에도 계층 존재

    * 디스패처
        - 내용물을 채워 넣거나 꺼내는 일을 담당하는 논리 회로, cpu칩에서 큰 영역을 차지함

    * 분기 예측 회로
    - 프리페치해서 캐시를 준비시키기 위해 조건 분기 명령어의 결과를 예측

    * 순서를 벗어나는 실행 처리 회로
    - 프로그램에 명시된 명령어 순서를 벗어나 가장 효율적으로 명령어를 수행하도록 함



## 코프로세서


- 프로세서 코어는 복잡한 회로로 이루어짐 -> 몇 가지 연산릉 코프로세서(단순한 회로)에 위임하여 공간 확보
    - 그래픽 처리 등 기능 담당

* 직접 메모리 접근(DMA)
- 스와핑 등 주 메모리와 디스크 사이에 단순한 데이터 복사 자주 일어남
- -> 데이터 복사만 담당하는 코프로세서 존재



## 메모리상의 데이터 배치


* 정적 데이터
    - 메모리에 담는 데이터
    - 프로그램 작성 시 얼마나 메모리가 필요한지 알고 있음

* 동적 데이터
    - 프로그램 실행 전에는 크기를 알 수 없는 데이터
        - ex. 메시징 시스템은 저장해야 할 메시지 개수나 크기를 미리 알지 못함
    - 정적 데이터가 차지하는 영역의 바로 위 영역(힙)에 쌓임

    - 더 많은 데이터를 저장할 경우, 스택은 아래로 자라고 힙은 위로 자람
        - -> 힙과 스택이 서로 충돌하지 않게 하는 것이 중요
        - 메모리 배치에는 몇 가지 사소한 변형 존재
            - 메모리의 시작/끝 부분에 인터럽트 벡터를 저장하는 영역이나, I/O장치를 제어하기 위한 레지스터를 확보하기도 함

    
## 프로그램 실행

* 라이브러리
    - 여러 프로그램에서 반복 사용할만한 함수를 모아놓은 것

- 프로그램은 여러 조각으로 이루어짐
    - 각 프로그램을 연결하기 편한 매개 파일로 나누고, 링커로 연결

    * 실행과 링크가 가능한 형식
        - 매개 파일 형식
        - 여러 섹션으로 이루어짐

    * 링커
        - 매개 파일의 내용을 해소(resolve)해서 실제로 실행할 수 있는 프로그램을 만드는 프로그램

        - 정적 링크: 라이브러리를 나머지 부분과 직접 연결해 실행 파일 만듦
            - -> 같은 라이브러리 반복 사용, 메모리 낭비 -> 공유 라이브러리를 사용하는 동적 링크 발명
            - => 여러 프로그램이 같은 라이브러리를 공유할 수 있게 함

    * 참고
    - 진입점: 프로그램의 첫 번째 명령어가 위치한 주소
    - 런타임 라이브러리: 프로그램을 이루는 모든 부분이 하나로 합쳐져, 실행파일을 이룰 때 추가됨. 
        - 런타임 라이브러리에 있는 명령어 실행(1) 후 , 진입점의 명령어 실행(2)
        - 메모리 설정을 책임    
            - 스택과 힙 영역을 설정, 
            - 정적 데이터에 위치한 초깃값 설정
        

## 메모리 전력 소비


- 데이터를 메모리로 옮기는 과정에서 전력이 소비됨
- 모바일 장치에서 중요한 일
- 코드 작성 시 유의


## 정리


- 메모리를 다루고, 사용을 개선하는 방법에 대해 학습함
- 이어지는 6장에서 I/O 학습 -> 현대적 컴퓨터에 대한 구조 이해