# Chapter_03. 메모리와 디스크의 핵심: 순차 논리

- 입력에 의해서만 출력이 결정되는 조합 논리(2장)에 이어, 입력의 현재 상태와 과거 상태를 함께 고려하는 순차 논리(3장)에 대해 학습
- 컴퓨터를 만들기 위해서는 조합 논리와 순차 논리 모두 필요
<br><br>

## 시간 표현과 상태 기억

- 우리는 주기 함수를 사용해 시간 측정 가능  *ex. 지구의 자전*
- 컴퓨터의 경우 전자공학 사용, 주기적인 전기 신호 필요

* 발진자
- feedback: 인버터의 출력을 입력에 연결한 트릭
    -> 반복하면서 출력치 0과 1사이를 진동
- 전극을 크리스털에 연결, 압축해서 전기를 생산 = 피에조 전기
    -> 마이크 등 음성 진동 기구에 쓰임

* 클록
- 시간을 잴 수 있게 해주는 신호
- 발진자는 컴퓨터에 클록을 제공
- 클록은 회로의 페이스를 결정
- 회로의 최대 클록 속도나 가장 빠른 템포는 회로의 전파 지연 시간에 의해 결정됨

- 컴퓨터 컴포넌트 제작에 필요한 통계
    - 비닝: 부품을 측정해서 그 특성에 따라 여러 다른 빈이나 무더기로 분류
        - 부품 전체의 편차보다는 더 작은 편차를 갖도록 부품을 빈에 나눠 담음
    - 오버클로킹: 빈의 중간 정도에 위치하는 부품을 고장 나지 않을 범위 안에서 클록을 빠르게 공급

* 래치
- 정보를 기억할 방법
- OR 게이트의 출력을 입력에 묶는 방식의 되먹임(feedback)사용
    - *이 회로는 자신의 과거 상태를 기억한다고 이해*
- S-R 래치: 액티브 로우를 입력받고 보수 출력을 제공

* 게이트가 있는 래치
- 어느 시점에 무엇을 기억할 것인지 적용?
- S-R 래치에 게이트를 한 쌍 추가
    - 게이트가 거짓(하이)인지, 참(로우)인지에 따라 출력값이 달라짐
    - 참일 때 입력값 반영
    - 게이트가 참인 경우 입력값의 변화가 출력에 나타난다는 한계

* 플립플롭
- 위에서 언급한 데이터 변경으로 인해 잘못된 결과가 생길 수 있는 경우 방지하기 위해, 논리 수준이 특정 값에 머무는 동안은 데이터를 잡아내지 않고 전이되는 순간의 데이터를 잡아내는 방법 사용
- 전이(edge) -> 시간에 대한 판정 기준
- 양에 에지에 의해 변화가 촉발되는 플립플롭 = D플립플롭, 0->1일 때 출력 변화
- 음의 에지에 의해 변화가 촉발되는 플립플롭 = 1->0일 때 출력 변화

* 카운터
- 플립플롭을 응용한 회로, 순서대로 수를 셈
- 리플 카운터 = 비동기 카운터
- 타이밍 다이어그램: 전파 지연을 감안해 4비트 수를 세도록 함
    - 전파 지연이 허용하는 것보다 빠른 속도로 입력을 변화시키면, 출력이 틀리는 경우 발생
    -> 동기적 카운터를 설계해서 해결
     ****책 그림 참고해서 이해*

* 레지스터
- 클록을 공유하는 여러 개의 D플립플롭을 한 패키지에 넣은 것
- 레지스터를 사용하면 쉽게 여러 비트를 저장할 수 있음

## 메모리 조직과 주소 지정
- 더 많은 정보를 저장하기 위해서 레지스터를 쌓아 둠<br>
-> 어떤 레지스터를 사용해야 하는지 어떻게 지정?<br>
-> 각 레지스터에 번호(주소)를 부여하자

- 메모리 칩에는 주소 버스와 데이터 버스가 존재
- 주소는 행과 열의 두 덩어리로 나눔
- 많은 메모리가 필요할 경우 행과 열 주소를 멀티플렉싱해서 레지스터에 저장
- 메모리 칩은 깊이X너비로 크기를 표시

* 임의 접근 메모리
    - RAM(Random Access Memory), 램
    - 원하는 곳은 어디든 원하는 순서로 쓰거나 읽을 수 있음

- 정적 램(SRAM): 비싸고 빠름, 각 비트에 트랜지스터가 6개 들어 감
- 동적 램(DRAM): capacitor에 전자를 담고 트랜지스터를 1개만 사용해 뚜껑을 덮는 방식
    - 가끔 메모리를 갱신해주어야함
    - 큰 메모리 칩에 사용됨
- 정적, 동적램은 모두 휘발성 메모리 / 코어 메모리는 비휘발성 램으로 비트를 토러스 모양의 쇳조각에 저장

* 읽기 전용 메모리
    - ROM(Read Only Memory), 롬
    - 초기 IBM 카드, 천공 종이 테이프, 코어 로프 메모리가 대표적인 롬 방식
        - 순차적 메모리의 한계
    - 마스크 프로그래머블
        - 임의 접근 가능한 메모리 등장
        - 고가 -> 칩이 많은 경우에만 사용 가능 -> PROM 발명
    - PROM(프로그래머블 읽기 전용 메모리) - EPROM(지울 수 있는 읽기 전용 메모리) - EEPROM(전기로 지울 수 있는 읽기 전용 메모리)형태로 발전

## 블록 장치
- 디스크 드라이브: 대용량 저장장치
    - 블록(섹터) 단위로 주소를 지정해 읽음
    - 모든 디스크 드라이브는 하드 드라이브이나, 플로피 디스크 등장으로 이와 구분하기 위해 하드 드라이브라는 명칭으로 불림
- 그 외 자기 드럼, 자기 테이프, 광학 디스크 존재

## 플래시 메모리와 SSD

* 플래시 메모리
    - 가장 최근 나타난 EEROM 유형의 매체
    - 음악 플레이어, 디지털 카메라에 적합
    - RAM처럼 원하는 위치를 마음대로 읽을 수 있음
    - 읽을 때는 임의 접근, 쓸 때는 블록 접근의 형태


* SSD(고체 상태 드라이브)
    - 디스크 드라이브는 점점 SSD로 대체되고 있음
    - 디스크 드라이브 모양의 패키지에 넣은 플래시 메모리와 같다고 이해

## 오류 감지와 정정

* 패리티
    - 단 1비트만 데이터가 잘못된 경우를 감지
    - 짝수 패리티는 모든 비트를 서로 XOR한 경우 사용
    - 홀수 패리티는 XOR한 값의 보수 사용
    - 오류가 홀수 번 발생한 경우만 알아낼 수 있다는 한계

* 오류 검사와 정정
    - 해밍 코드 회로가 내장된 메모리 칩
    - 소비자용 장치가 아닌 데이터 센터 등에 쓰임
    - 체크섬, 순환 중복 검사 등 이용

## 하드웨어와 소프트웨어 비교

- 논리를 하드웨어로 만드는 것과 소프트웨어로 만드는 것을 구분하기는 모호함
- 소프트웨어는 설계 외에 어떤 비용도 들지 않기에 더 만들기 쉽다는 것만 차이점
- 칩 설계는 완전한 커스텀 -> 게이트 배열 -> FPGA(현장에서 프로그램 가능한 게이트 배열)로 발전해 옴

## 정리

- 컴퓨터가 시간을 어떻게 인식하는지에 대해 살펴 봄
- 2장의 조합 논리 + 3장의 순차 논리가 기본적인 하드웨어 요소가 됨
