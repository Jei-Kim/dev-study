# Chapter_04. 컴퓨터 내부 구조

- 컴퓨터: 전자 부품을 다양하게 조합해 비트를 조작하는 회로
    - 컴퓨터는 크게 메모리, 입력과 출력, cpu 세 가지 부분으로 구성됨

## 메모리

- 조작할 비트들을 저장할 장소
- 메모리 = 집이 늘어선 거리라고 생각할 때, 각 집에는 주소가 부여됨
- 구체적인 위치의 메모리를 가리킬 때 '메모리 위치'를 자주 사용
- 메모리의 기본 단위는 바이트
- 프로세서(ex. 인텔, 모토로라)에 따라 바이트의 위치 배정이 다름
- 바이트의 배열 특성을 엔디안이라 표현함
    - 시스템 간의 데이터 전송에는 엔디안을 고려해야 함
    - 바이트 순서와 관련된 문제를 nuxi syndrome이라 칭함

## 입력과 출력

- 입력과 출력을 담당하는 장치를 I/O 장치 혹은 주변장치(peripheral)라고 함
- 보통 표준 입력/출력 슬롯에 따라 일관된 방식으로 장치를 연결

## 중앙처리장치

- 실제 계산을 처리하는 컴퓨터 부품

* 산술 논리 장치(ALU)

    - cpu의 핵심 부품
    - 산술 계산, 불리언 대수 및 기타 연산 수행

    - 연산 코드가 피연산자에 대해 어떤 연산자를 적용할 지 결정
    - 조건 코드에는 결과에 대한 추가 정보가 들어감

* 시프트

    - 왼쪽 시프트는 모든 비트를 왼쪽으로 1비트씩 옮기고, 맨 왼쪽은 버리고 맨 오른쪽 비트에 0을 넣는다. (곱하기 2와 같음)
    - 오른쪽 시프트는 오른쪽으로 1비트씩 옮기고, 맨 오른쪽은 버리고 맨 왼쪽에 0을 넣는다. (나누기 2를 하고 나머지를 버리는 것과 같음)

* 실행 장치

    - == 제어장치
    - 산술 논리 장치에게 할 일을 알려주는 역할
        - 실행 장치에 명령어 목록을 제공하기 때문
    - 명령어: 컴퓨터에게 어떤 일을 할지 알려주는 비트 패턴, 표준 없음
    - 프로그램 카운터(pc): 실행 장치가 메모리에서 명령어를 가져오기 위해 위치를 알 수 있도록 함, 메모리 위치를 가리킴(참조함)
    - 명령어 수행 후 카운터가 증가함

## 명령어 집합

* 명령어

- DRAM 주소 지정 기법
: 주소 확장 레지스터를 두고 별도의 명령어를 사용해 상위 주소를 지정

- == 물리 주소 확장(PAE)
- 시간, 메모리 낭비되는 단점

- 3주소 명령어 구성
: 명령코드, 피연산자1, 피연산자2, 결과라는 네 가지 필드로 구성

- 새 가지 메모리 위치를 한꺼번에 지정해야 함 -> 불가능 -> 피연산자들의 내용을 저장하는 레지스터 추가해 명령어를 처리

- 1주소 명령어 구성
: 3주소 명령어 구성에 누산기, 저장 명령어를 추가한 방식

* 주소 지정 모드

- 직접 주소 지정보다 간접 주소 지정을 추가하면 더 많은 메모리를 사용할 수 있음

    - 간접 주소 지정 시 명령어의 값을 피연산자 주소로 해석 x
    - ->  피연산자 주소를 얻을 수 있는 메모리 위치를 가리키는 주소로 사용

- 상수를 누산기에 넣어야 할 경우, 즉시 주소 지정 모드 추가

    - 주소에 해당하는 비트를 값으로 간주함

- 속도 빠르기는 즉시 주소 지정, 직접 주소 지정, 간접 주소 지정 순

## 조건 코드 명령어

* 분기 명령어

- 순서대로 수행하는 것이 아닌, 의사결정을 내리고 코드 중 일부를 선택적으로 실행할 수 있는 프로그램 필요

    - 프로그램 카운터의 값을 변경할 수 있는 명령어 필요
    - 이러한 명령어를 분기 명령어라고 부름
    - 조건에 따라서 분기하도록 조건을 저장하는 비트가 존재

- 프로그램 카운터의 내용을 변경할 때, 두 가지 명령어 존재

    - pca: 현재 프로그램 카운터 값을 누산기에 복사
    - apc: 누산기의 값을 프로그램 카운터에 복사

## 최종 명령어 집합 구성

- 최종 명령어 구성은 모드, 명령코드, 주소로 구성됨
- 주소 지정 모드(위)를 선택하는 데 2비트 필요
- 여기까지 구성된 것들로 명령어 코드 및 피보나치 수열을 계산하는 기계어를 작성 가능

## 마지막 설계

* 명령어 레지스터

- 컴퓨터가 처음으로 하는 일은 메모리에서 명령어를 가져오는 fetch이다.
    - -> 이후 명령어를 어떻게 실행할 지 결정

- cpu 명령어 레지스터에는 현재 실행중인 명령어를 저장할 수 있다.

 ---------------------------------------------------------------------------
 프로그램 카운터 ---(주소 버스)--> 메모리 --(데이터 버스)--> 명령어 레지스터
 ---------------------------------------------------------------------------

* 데이터 경로와 제어 신호

- 프로그램 카운터의 값을 메모리 주소 버스에 넣을 방법,
메모리에 있는 데이터를 명령어 레지스터로 넣을 방법 고안 필요
- 앞서 살펴 본 개념들로 데이터 경로와 제어 신호가 구성됨 (그림 4-22 참조)
    - 간접 주소 지정 시 메모리에서 읽어 온 주소를 저장할 간접 주소 레지스터가 추가됨

* 데이터 흐름 제어

- 페치와 실행에 여러 단계가 필요 -> 각 단계를 추적할 카운터 필요
    - 카운터의 내용과 명령어의 명령코드와 모드 부분이 제어신호 결정
    - 카운터는 2비트 카운터

- 랜덤 논리를 통한 교통 제어, 메모리를 사용한 교통 제어 가능
    - 두 가지 모두 옳은 논리이고 상태 기계이자 컴퓨터임
    - -> 이렇게 작은 컴퓨터로 큰 컴퓨터를 구현하는 방법을 마이크로코드를 사용했다고 표현하며,
    메모리 내의 내용 = 마이크로 코드이다.

- 마이크로코드 메모리는 ROM이 주로 사용됨.
- 보통 일반 사용자가 마이크로코드를 변경하도록 허용하지 않음

## RISC와 CISC 명령어 집합

- 수많은 명령어가 존재하지만, 복잡한 명령어 중 상당수는 쓰이지 않음
    - -> 실제로 쓰이는 명령어만을 포함하는 기계(RISC) 등장
    - 기존 설계 방식으로 만든 컴퓨터는 SISC라 칭함

* RISC 기계

- 적재-저장 구조 사용
    - 메모리와 레지스터를 오가는 명령어들과, 레지스터 간 명령어로만 이루어짐

- 시간이 지남에 따라 명령어들이 더해져, 현재 RISC는 오래 전의 SISC보다 복잡

* CISC 기계

- 대표적으로 PDP-11이 있음
    - ALU의 역할의 범용 레지스터가 8개 존재
    - 자동증가, 자동감소 주소 지정 모드 지원
    (레지스터 사용 전/후로 레지스터 내의 값을 감소시키거나 증가시켜주는 모드)
    - C언어가 PDP-11에서 최초로 만들어짐
        - C언어의 포인터는 간접 주소 지정을 추상화한 것
    - C언어는 이후 C++, 자바, 자바스크립트 등 많은 언어에 영향

## GPU

- 그래픽 처리 장치
- GPU는 CPU에 있는 모든 요소가 필요하지는 않음
- 간단한 처리 장치가 아주 많이 들어 있음
- CPU보다 메모리 버스의 폭이 넓음 -> 메모리에 더 빠르게 접근 가능
- 시간이 지나 더 일반적인 용도에 쓰이게 됨
    - 공학계산, 인공지능, 비트코인 채굴 등

## 정리

- 1~3장까지의 내용들로 실제 컴퓨터를 만들어 봄
    - 간단하지만 실제로 만들 수 있고 프로그래밍도 가능한 기계임

- 실제 우리가 사용하는 컴퓨터가 되기 위해서는 이에 스택, 메모리 관리 하드웨어 등 몇 가지의 요소가 추가로 필요
    - -> 5장에서 이어짐
