# Chapter 08. 프로그래밍 언어 처리


## 어셈블리 언어

* 특징

    - 비트 조합을 외우지 않아도 '니모닉'을 통해 명령어를 작성 가능
    - 주소에 이름(레이블)을 붙일 수 있음
    - 코드에 주석을 달아서 이해를 도울 수 있음

* 어셈블러

    - 어셈블리 언어로 작성된 코드를 읽어서 동등한 기계어 코드를 생성해주는 프로그램
    - 변환 과정에서 레이블, 심볼의 값을 채워 넣음 -> 명령어 위치가 바뀌어 생기는 오류를 방지

* 부트스트랩
    - = 부트
    - 어셈블러가 존재하지 않았을 때부터 어셈블러의 등장, 발전해오기까지의 점진적인 과정 속에서 등장한 용어  



## 고수준 언어

- 간단한 일을 수행하는데도 많은 작업이 필요한 어셈블리 언어의 단점 -> 보완을 위해 고수준 언어 등장
- 고수준 언어는 어셉를리 언어보다 더 높은 추상화 단계에서 동작

- 고수준 언어의 코드는 컴파일러라는 프로그램에 의해 실행
    - 컴파일러: 소스코드를 기계어로 번역(컴파일)

- 기계어 코드 = 목적 코드

- 고수준 언어는 수천가지 존재

- 초기 고수준 언어로는 '포트란' 이 있음
    - 포트란은 큰 기계에서만 작동 -> 더 작은 기계에서도 동작하는 언어들 등장하기 시작(ex.베이직)

- 베이직 등의 언어 또한 프로그램이 복잡해지면서 연결을 관리하기 어려운 문제점 등 존재


## 구조적 프로그래밍

- 포트란, 베이직 언어는 비구조적 언어임
    - GOTO와 레이블을 조합할 때 구조의 제약이 없기 때문
    - 비구조적 언어인 초기 포트란은 점진적 발전을 거쳐 구조적 프로그래밍 개념을 포함시켜 옴

- 구조적 프로그래밍은 잘못된 GOTO사용으로 발생할 수 있는 스파게티 코드 문제를 해결하기 위해 개발됨
    - 파스칼, C, C++, 자바, PHP, 파이썬, 자바스크립트 등
    - 파스칼, 자바스크립트는 GOTO를 없앰



## 어휘 분석

- 어휘 분석이란, 코드를 '기호'로부터 단어와 같은 '토큰'으로 변환하는 과정

* 상태 기계

    - 상태로 이뤄진 집합과, 한 상태에서 다른 상태로 전이되는 원인의 목록으로 이루어진 기계
    - 간단한 코드를 사용해 입력을 분류할 수 있음


* 정규식

    - 언어를 지정하기 위한 언어를 정의

    - 유닉스 grep 유틸리티 명령을 시작으로 정규식이라는 말이 널리 쓰이기 시작
        - -> 현재는 대부분의 프로그램에 정규식 언어 존재

    - 정규식 자체 = 언어
        - 서로 호환되지 않는 몇 가지의 정규식 존재

    - 패턴 매칭에서 중요한 역할
        - ex. 부동소수점 수를 표현하는 정규식

    - 정규식을 활용한 도구 점차 발전
        - ex. lex, flex
        - 입력이 정규식과 매치될 때, 사용자가 제공한 프로그램 조각 실행



## 단어에서 문장으로


* yacc
    - 상태 테이블 생성, 이 테이블을 사용해 작동하는 코드를 생성
    - 스택을 사용하는 시프트-리듀스 파서 프로그램 생성
        - 시프트: 토큰을 스택에 넣음
        - 리듀스: 스택의 맨 위부터 매치된 토큰들을 다른 것으로 대체



## 누구나 프로그래밍 언어를 만들 수 있는 시대


- 과거와 달리 프로그래밍 언어를 개발하는 데 있어 큰 제약이 없어짐
    - 수많은 언어 등장
    - 언어의 역사를 제대로 이해하지 않을 경우, 과거 언어의 한계를 그대로 가져오는 경우도 있음

- 언어의 구체적인 응용을 위해서는 도메인 특화 언어를 살펴볼 필요 O
    - pic, chem 등



## 파스 트리


- 고수준 언어를 실행하는 방법은 컴파일, 인터프리터 존재
- 인터프리트인지 컴파일인지는 언어 설계 자체보다는 구현에 의해 이뤄짐

* 컴파일러
    - 소스 코드를 구체적인 기계에 맞는 기계어로 번환
    - 같은 프로그램에 대해 다른 컴파일러를 사용하면 다른 대상 기계를 위한 프로그램 만들어 낼 수 있음
    - 컴파일이 완료되면, 실행할 준비가 된 것

* 인터프리터 언어
    - 실제 기계에 사용할 기계어를 만들어내지는 않음
    - 가상 머신에서 실행됨

    * 가상 머신
        - 소프트웨어로 작성된 기계
        - 자신만 실행할 수 있는 기계어를 제공하지만, 이 기계어는 실제 컴퓨터 명령어 집합은 아님
        - 최근에는 추상적인 계산 기계를 뜻하기도 함에 유의할 것

    - 일부 인터프리터 언어는 인터프리터에 의해 직접 실행되기도, 나중에 해석될 수 있도록 중간어로 컴파일되기도 함
    
    - 컴파일이 된 코드는 기계어이기 때문에 더 빠르게 실행되나, 인터프리터에 의해 실행되는 코드는 즉시 번역되는 것처럼 수명이 짧음
    
    - 일반적으로 컴파일러나 인터프리터는 파스 트리를 구성
        - 파스트리: 언어 문법으로부터 만들어낸 DAG(유향 비순환 그래프) 데이터 구조
            - 노드 구조로부터 만들어 낼 수 있음
            - ex. 간단한 계산기 파스트리 (그림 8-6 참고)


## 인터프리터

- 파스 트리의 함수 호출 -> 인터프리터가 파스 트리를 실행하게 함

- 실행
    - 1) 연결 리스트 순회
    - 2) 계산
    - 노드에 있는 코드를 사용해 어떤 일을 할 지 결정
    - 변수와 변수의 값을 저장하는 함수, 변수에 연관된 값을 검색하는 함수는 해시 테이블 사용

- 리스트 순회와 계산 코드를 yacc에 붙여넣음으로써 파스 트리를 즉시 실행하거나,
    파일에 저장된 파스 트리를 나중에 읽어서 실행하는 방법 존재

    - 자바, 파이썬 등은 후자 방법으로 작동됨

    - 이 때 파일에 저장되는 것은 소프트웨어로 구현된 기계의 명령어

    - 모든 대상 기계에 저장된 파스 트리를 실행하는 프로그램이 존재해야 함
    - -> 똑같은 인터프리터 소스 코드를 여러 대상 기계에 대해 컴파일해 사용하는 경우도 자주 발생 

- 구조
    - 인터프리터의 프론트엔드는 어휘 분석 -> 문법 파싱으로 파스트리 생성
    - 파스 트리는 중간 언어로 표현됨
    - 백엔드는 이 언어를 실행할 대상 하나(기계)마다 존재



## 컴파일러

- 인터프리터 구조와 유사하나, 백엔드 실행 코드 대신 코드 생성기가 존재

* 코드 생성기
    - 특정 대상 기계에 대한 기계어 코드를 생성
        - C 등 일부 언어는 대상 기계의 어셈블리 언어 코드 생성, 대상 기계의 어셈블러를 이용해 기계어로 번역

- 컴파일된 기계어로 실행하면 코드가 더 작고 효율적, 인터프리터로 실행할 때보다 실행 속도 빠름



## 최적화


- 대부분의 언어 도구에는 파스 트리와 코드 생성기 사이에 최적화기라는 단계가 들어 감
    - 파스트리를 분석, 이를 활용해 더 효율적인 코드를 생성하도록 파스 트리 변환

- 최적화기에는 다양한 트릭이 쓰임

    - 루프 불변 요소(루프를 반복해도 변하지 않는 값)을 알아 내 재구성

    - 강도 절감: 비용이 많이 드는 연산을 더 적게 드는 연산으로 대신
        - ex. 곱셈을 덧셈으로 대체



## 하드웨어를 다룰 때 주의하라


- 하드웨어를 조작하는 코드를 최적화하면 예기치 못한 문제 발생할 수 있음 -> 주의 필요

    - 경우에 따라 최적화를 꺼야할 수도 있음

    - 대개 소프트웨어를 일반적인 파일 / 하드웨어에 따라 달라지는 파일로 구분하여, 일반적인 파일에만 최적화를 적용하는 식으로 문제 해결

    - 일부 언어에서는 최적화를 하지 않아야 하는 부분을 알려주는 매커니즘을 제공하기도 함
        - ex. C언어에서 volatile 키워드는 변수에 대한 접근을 최적화하지 말라고 지정



## 정리


- 프로그램을 기계에서 실행하기 위한 변환 방법, 컴파일과 인터프리트에 대해 학습함

- 이어서 인터프리터의 일종인 '웹 브라우저'와 웹 브라우저가 인터프리트하는 언어에 대해 학습

