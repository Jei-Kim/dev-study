# Chapter 07. 데이터 구조와 처리

- 데이터를 조직하는 표준적인 방법(데이터 구조)에 대해 알아 봄.
- 참조 지역성이란, 필요한 데이터를 메모리에서 서로 인접한 곳에 유지하는 것



## 기본 데이터 타입

- 기본 데이터 타입에는 크기와 해석 두 가지 측면이 존재
    - 크기: 비트 수
    - 해석: 부호 유무, 부동소수점 여부, 문자를 나타내는지 등

- 포인터: 크기의 부호가 없는 정수, 정숫값이 아닌 메모리 주소로 해석됨
    - 값이 0인 포인트 == NULL
    - 일부 언어는 포인터 사용으로 인한 오류를 방지하려고 참조(reference)라는 개념 도입 --> 뒤에 이어짐
    - '집'으로 비유됨



## 배열

- '아파트'로 비유됨
    - 아파트 한 동에는 주소가 있고, 한 아파트 동 안의 각 집에는 호수가 있다
    - 호수 == 인덱스
    - 집 == 원소(element)
    - 배열 내 원소의 타입이 모두 같아야 함

* 오프셋 주소
    - 0번째 원소의 주소인 기저 주소로부터 얼마나 멀리 떨어져 있는지를 나타냄

- 1차원 배열, 다차원 배열 존재

- 언어가 인덱스 검사를 지원하지 않는 경우 존재 -> 보안상 문제점 발생할 가능성 높음 -> 주의



## 비트맵


- 표현하고 싶은 정보가 기본 데이터보다 훨씬 작은 경우, 비트맵(비트의 배열)을 이용함

- 비트맵의 기본 연산
    - 비트 설정하기, 비트 지우기, 비트가 1인지 검사하기, 비트가 0인지 검사하기

- 정수 나눗셈을 통해 특정 비트가 들어 있는 바이트를 찾을 수 있음
    - 나누기 8, 3비트 오른쪽 시프트 수행

- 마스크: 비트 패턴

- 자원이 사용 가능한지 여부를 나타낼 때도 비트맵이 사용됨
    - 사용중인 자원을 비트로 표현 -> 0이 하나라도 있는 바이트를 찾기 위해 배열을 검색



## 문자열


- 문자열(string): 여러 문자로 이뤄진 시퀀스

- 배열 크기가 아닌, 문자열의 길이를 알아야 할 때

    1. 문자열 안에 길이를 저장하는 방법
        - 첫 번째 바이트에 문자열 길이를 넣음 
            - -> 225자로 제한된다는 단점이 있음

    - 2. 문자열 터미네이터를 사용하는 방법
        - 길이를 저장하는 대신, 마지막에 문자의 끝을 알리는 nul과 같은 특정 문자(문자열 터미네이터)를 넣음
            - C에서 쓰임
            - 저장이 쉽지만, 문자열 길이를 알아내려면 끝까지 스캔해야 한다는 단점이 있음



## 복합 데이터 타입


- 구조체: 단순한 공간을 넘어, 원하는 대로 데이터 타입을 만들 수 있는 방법
    - 구조체 == 스위트룸, 멤버 == 스위트룸 안의 각 방

- 편의문법: 프로그램을 더 편하고 이해하기 쉽게 만들어주는 문법적 요소
    - 편의문법에 어떤 것들이 속하는지에 대한 논쟁 o (관점에 따라 다름)

- 프로그래밍은 멤버 순서, 메모리 정렬 등 지킬 요소가 다수 존재함
    - 모든 요소를 지키다보면 정렬의 경계가 중복되는 경우 발생 -> 패딩을 필요한만큼 추가해서 해결

- 유닉스 에포크

    - 날짜와 시간을 표현할 때 많은 시스템에서 사용하는 표준

    - 1970년 1월 1일 기준, 몇 초가 지났는지 표현하는 32비트 수를 사용
        - 2038년 모든 비트를 소진할 것을 대비, 대부분의 시스템에서 64비트로 확장함



- 공용체(union): 움직일 수 있는 파티션으로 구분한 데이터 구조
    - 구조체 안의 모든 멤버는 각기 다른 메모리를 차지하는 데 반해, 공용체의 멤버들은 메모리를 공유할 수 있음



## 단일 연결 리스트


- 배열은 효율적인 방법이나, 데이터양이 정해져 있지 않은 경우에는 적합하지 않음
    - 배열의 크기를 미리 정하거나, 추가/수정/삭제 시 불편함
    -  -> 연결리스트를 사용하는 것이 효과적

- 단일 연결 리스트
    - 헤드: 리스트의 맨 앞
    - 테일: 리스트의 마지막
    - next: 다음 원소를 저장하는 포인터

- 배열과의 차이점
    - 배열: 각 원소는 메모리에서 연속적으로 위치 
    - 리스트: 각 원소는 메모리의 아무 위치에나 있을 수 있음


## 동적 메모리 할당 


- 프로그램 데이터 공간에는 정적으로 할당된 데이터 영역과, 프로그램 런타임 라이브러리가 설정해주는 힙 영역이 존재
    - 별도의 메모리 관리 유닛(mmu)이 없는 경우: 힙 영역이 프로그램에 사용할 수 있는 모든 데이터 메모리
    - 별도의 메모리 관리 유닛(mmu)이 있는 경우: 런타임 라이브러리가 프로그램에게 필요한 메모리 용량을 운영체제에 요청

- 브레이크: 프로그램이 사용할 수 있는 메모리의 끝

- 배열 등의 변수가 사용하는 메모리는 정적 메모리
    - 할당받은 주소는 바뀌지 않음

- 리스트 노드 등은 동적 메모리
    - 필요에 따라 생기기도 하고 사라지기도 함
    - 힙에서 메모리를 얻음

- 프로그램은 힙을 관리할 줄 알아야 함
    - 사용 중인 메모리와 사용 가능한 메모리 판단

- 파편화: 메모리를 다 소진하지 않았지만, 가용불가인 작은 메모리만 남은 경우



## 더 효율적인 메모리 할당


- 메모리를 할당하는 방식에 따라 메모리와 비용을 줄일 수 있음
    - ex. 문자열이 들어 있는 리스트 노드 -> 노드와 문자열을 동시에 할당



## 가비지 컬렉션 


- 자바, 자바스크립트에는 malloc, free(C언어) 대신 가비지 컬렉션 구현으로 동적 메모리 할당 지원

- 자바는 포인터 대신 참조 사용
    - 참조는 포인터를 추상화, 실제 메모리 주소를 노출하지는 않음

- 가비지 컬렉션을 사용하는 언어에는 데이터 요소를 만들어내면서 이 요소가 사용할 메모리도 할당해주는 new 연산자를 사용

- 프로그래머가 가비지 컬렉션 시스템을 제어할 수 없음 -> 불필요한 참조 발생 -> 메모리 낭비 문제



## 이중 연결 리스트


- 노드에 다음 원소에 대한 포인터 + 이전 원소에 대한 포인터 들어 있음
    - 단일 연결 리스트가 이전 원소를 찾기 위해 들이는 시간적 비용 극복



## 계층적인 데이터 구조


- 데이터를 효율적으로 가져오고 싶은 경우, 앞서 살펴 본 선형 구조보다 계층 구조가 실용적임

- 2진트리
    - 가장 간단한 계층적 데이터 구조
    - 노드가 최대 2개의 다른 노드와 연결될 수 있다는 뜻
    - 루트: 리스트의 헤드와 같은 개념, 맨 위 노드

- 트리의 노드 구성은 원소 삽입 순서에 따라 달라짐

- 어떤 대상을 검색하는 연산은 트리 깊이에 의해 정의됨



## 대용량 저장장치

- 블록: 데이터의 기본 단위
- 클러스터: 연속적인 블록

- 데이터 저장 시 하나의 큰 블록에 담는 것이 아니라, 고정된 여러 개의 블록에 나눠 담아야 함

- 메모리에 있는 정보는 일시적 -> 데이터을 디스크에 저장하기 위해서는 영구적인 존재 필요 -> '파일 이름'

- 아이노드 == 인덱스 + 노드
    - 파일 이름을 디스크에 저장할 방법
    - 파일의 데이터가 저장된 디스크 블록을 연결해줄 방법

    - 직접 블록 포인터
        - 아이노드에는 12개의 직접블록이 존재
        - 4096 * 12 = 49,152바이트까지 데이터를 보관할 수 있음

    - 간접 블록
        - 직접 블록 포인터가 저장할 수 있는 범위보다 큰 파일 저장 시에 사용
        - 2중 간접, 3중 간접 블록을 통해 총 4PiB까지 저장

    - 아이노드에는 디렉터리 정보가 존재, 파일 이름과 파일 데이터를 가리키는 아이노드를 연결
        - 디렉터리는 다른 디렉터리 참고 가능, 이로 인해 트리 구조의 계층적 파일 시스템 존재

    - 여러 아이노드가 같은 블록을 참조 가능 



## 데이터베이스


- 정해진 방식으로 조직화된 데이터 모음

- 데이터베이스 관리 시스템
    - 데이터베이스에 정보를 저장하고 읽어올 수 있게 해주는 프로그램
    - 보톤 맨 아래 데이터 저장 메커니즘을 감싼 여러 계층의 인터페이스로 구성됨

- b트리를 기반으로 만들어짐



## 인덱스


- 저장된 데이터에 접근하는 방식은 여러 가지

- 인덱스가 둘 이상으로 구성되기도 함

- 데이터가 바뀔 때마다 모든 인덱스를 갱신해야 하는 단점이 있지만, 데이터 변경보다 검색이 더 자주 발생하기 때문에 감내할만한 비용임



## 데이터 이동


- 데이터를 이동시키기 위해 많은 시간이 소비됨 -> 효율적으로 데이터를 이동시킬 수 있는 방법들 고안 시작
    - 루프 언롤링, 더프의 장치 등을 활용해 메모리를 0으로 설정하는 방법 사용됨

- 블릿
    - 원본과 복사본의 주소를 고려해, 빠른 복사가 이뤄지도록 최적의 코드를 즉각 생성해내는 코드
        - -> 자바 등 여러 언어의 가상 머신에서 사용 중인 JIT(just-in-time, 즉시 컴파일)의 기반



## 벡터를 사용한 I/O


- 데이터를 효율적으로 복사하는 것은 중요하나, 복사 자체를 최대한 피하는 것이 컴퓨터 성능에 더 효과적임

- 벡터: 같은 데이터가 연속적으로 모여 있는 고정된 크기의 데이터 구조

- 크기와 데이터에 대한 포인터로 이뤄진 벡터를 운영체제에 넘김 -> 운영체제는 벡터에 저장된 데이터를 사용해 데이터 조합
    - 읽기/쓰기에 모두 사용 가능
    - 수집: 벡터를 사용해 데이터를 쓰는 행위 -> 여러 위치에서 데이터를 모음
    - 분산: 벡터를 사용해 데이터를 읽는 행위 -> 여러 위치로 데이터를 분산시킴 

- 분산/수집은 인터넷의 근간이 된 버클리 네트워크 코드의 주류가 됨



## 객체 지향의 함정


- 객체 지향 프로그래밍을 주의 깊게 사용하지 않을 경우, 성능 문제가 발생할 수 있음

- 객체 지향은 C++을 통해 널리 사용되기 시작

- 객체에는 함수에 해당하는 메서드와 데이터에 해당하는 프로퍼티가 들어 있음

- 객체에 필요한 모든 데이터와 함수는 한 데이터 구조 안에 모여 있음
    - C는 타입 캐스팅과 포인터를 지원하기 때문에 이러한 구조 안에서 큰 이점 제공

- 객체는 전역적으로 알려진 함수 대신에, 자신이 사용할 메서드에 대한 포인터를 가지고 다녀야 함
    - -> 성능에 주안점을 둘 경우, 전통적인 배열을 사용하는 것이 더 좋은 방법일 수 있음



## 정렬


- 데이터를 정렬해서 저장 -> 메모리 접근 횟수 감소 -> 검색 속도 단축 가능

- 정렬 대상이 포인터보다 큰 경우
    - 대상을 정렬하는 대신 포인터를 재배열하는 방식을 사용

- qsort 
    - 유닉스 라이브러리 함수를 통해 지원 시작, 퀵정렬 구현
    - 함수 포인터를 활용
    - 데이터를 정렬하는 법은 알지만 데이터를 비교하는 방법은 알지 못함

- strcmp    
    - C
    - 아스키 코드를 바탕으로 함
    - 문자열 비교 시, 아스키 코드 외의 로케일을 지원해야 하면 문제 발생
    - 문자만 비교 순서를 제공하거나, 언어에 따라 정렬 규칙이 달라지는 부작용



## 해시


- 해싱
    - 검색에 사용할 키(동일성을 판정하는 기준)에 대해 해시 함수를 적용
    - 빠른 검색 속도
    - 해시 함숫값의 범위가 너무 크면 데이터를 과다하게 사용하거나, 넓게 흩어져 메모리 접근 성능이 저하됨
    - 키에 대한 사전 정보가 없기 때문에 완벽한 해시 함수를 만들기는 불가능

- 해시 테이블
    - 해시 함수의 결과를 배열 인덱스로 활용
    - 배열의 각 원소를 버킷이라고 함

- 해시 함수의 값이 같은 경우를 충돌이라 하며, 해시 체인으로 충돌을 해결할 수 있음
    - 해시 체인을 관리하는 방법 여러 가지 존재
        - 삽입 정렬 등

- 완전 해시
    - 각 키를 유일한 버킷에 연결



## 효율성과 성능


- 데이터베이스 샤딩
    - = 수평 파티셔닝
    - 데이터베이스를 각각 다른 기계에서 실행되는 여러 샤드로 나누는 방식

- 맵리듀스
    - 샤딩의 변종
        - 컨트롤러가 중간 결과를 모으는 방법을 코드로 직접 작성할 수 있게 함



## 정리

- 데이를 잘 조직화하는 방법에 대해 학습함 
- 이어서, 사람이 작성한 프로그램을 하드웨어가 이해할 수 있는 형태로 변환하는 방법에 대해 학습