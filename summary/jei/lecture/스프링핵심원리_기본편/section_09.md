## SECTION 9 _ 빈 스코프

<br>

### 빈 스코프란?

- 스프링 빈이 스프링 컨테이너의 시작과 함께 생성되어서 스프링 컨테이너가 종료될 때 까지 유지된다고 학습
    - -> 이것은 스프링 빈이 기본적으로 싱글톤 스코프로 생성되기 때문

* 스프링은 다양한 스코프 지원

    - 싱글톤: 
    기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프

    - 프로토타입: 
    스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프

    - 웹 관련 스코프
        - request: 웹 요청이 들어오고 나갈때 까지 유지되는 스코프

### 프로토타입 스코프

- 프로토타입 스코프를 스프링 컨테이너에 조회하면 스프링 컨테이너는 항상 새로운 인스턴스를 생성해서 반환
    - vs (싱글톤 스코프의 빈을 조회하면 스프링 컨테이너는 항상 같은 인스턴스의 스프링 빈을 반환)

* 정리
    - 핵심은 스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리한다는 것
        - -> 클라이언트에 빈을 반환한 이후에는 프로토타입 빈을 관리하지 않음
        - -> 프로토타입 빈을 관리할 책임은 프로토타입 빈을 받은 클라이언트에 있음

- SingletonTest 생성 -> 실행
    - 결과: 빈 초기화 메서드를 실행하고, 같은 인스턴스의 빈을 조회하고 종료 메서드까지 정상 호출 된 것을 확인

- PrototypeTest 생성 -> 실행
    - 결과: 프로토타입 빈을 2번 조회했으므로 완전히 다른 스프링 빈이 생성되고, 초기화도 2번 실행된 것을 확인
        - (싱글톤 빈은 스프링 컨테이너 생성 시점에 초기화 메서드가 실행 되지만, 프로토타입 스코프의 빈은 스프링 컨테이너에서 빈을 조회할 때 생성되고, 초기화 메서드도 실행되기 때문)
    - 프로토타입 빈은 스프링 컨테이너가 생성, DI, 초기화까지만 관여
    -> 스프링 컨테이너가 종료될 때 @PreDestroy같은 종료 메서드가 실행되지 않음

* 프로토타입 빈 특징 정리
    - 스프링 컨테이너에 요청할 때 마다 새로 생성됨
    - 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입 그리고 초기화까지만 관여한다.
    - -> 종료 메서드가 호출되지 않음
    - -> 프로토타입 빈은 프로토타입 빈을 조회한 클라이언트가 관리해야 함(종료 메서드에 대한 호출도클라이언트가 직접)

### 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 문제점

- 스프링 컨테이너에 프토토타입 스코프의 빈을 요청하면 항상 새로운 객체 인스턴스를 생성해서 반환하는데, 싱글톤 빈과 함께 사용할 때는 의도한 대로 잘 동작하지 않으므로 주의할 것

1. 스프링 컨테이너에 프로토타입 빈 직접 요청

    - SingletonWithPrototypeTest1 - prototypeFind()
        - 클라이언트A는 스프링 컨테이너에 프로토타입 빈을 요청
            -> 스프링 컨테이너는 프로토타입 빈을 새로 생성해서 반환(x01)
        - 클라이언트B는 스프링 컨테이너에 프로토타입 빈을 요청한다.
            -> 스프링 컨테이너는 프로토타입 빈을 새로 생성해서 반환(x02)
        - 각각의 count가 0에서 1이 되는 것 확인

2. 싱글톤 빈에서 프로토타입 빈 사용

    - SingletonWithPrototypeTest1 - singletonClientUsePrototype()

    - clientBean이라는 싱글톤 빈이 의존관계 주입을 통해서 프로토타입 빈을 주입받아서 사용하는 예제
        -  clientBean 은 싱글톤이므로, 보통 스프링 컨테이너 생성 시점에 함께 생성되고, 의존관계 주입도 발생
        - 스프링 컨테이너는 프로토타입 빈을 생성해서 clientBean 에 반환한다. 프로토타입 빈의 count 필드 값은 0
        - clientBean 은 프로토타입 빈을(정확히는 참조값을) 내부 필드에 보관
        - 클라이언트A 요청 시 count가 1이 되고, 클라이언트B가 요청시 2가 됨

        - *** clientBean이 내부에 가지고 있는 프로토타입 빈은 이미 과거에 주입이 끝난 빈이다. 주입 시점에 스프링 컨테이너에 요청해서 프로토타입 빈이 새로 생성이 된 것이지, 사용 할 때마다 새로 생성되는 것이 아니다 ***

        - 스프링은 일반적으로 싱글톤 빈을 사용하므로, 싱글톤 빈이 프로토타입 빈을 사용하게 됨
            -  싱글톤 빈은 생성 시점에만 의존관계 주입을 받기 때문에, 프로토타입 빈이 새로 생성되기는 하지만 싱글톤 빈과 함께 계속 유지되는 것이 문제
            - -> 해결방법 다음 강의에 이어짐

### 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 Provider로 문제 해결

- 싱글톤 빈과 프로토타입 빈 함께 사용 시, 사용할 때마다 새로운 프로토타입 빈을 생성하는 방법?

1. 스프링 컨테이너에 요청
    - 싱글톤 빈이 프로토타입을 사용할 때마다 스프링 컨테이너에 새로 요청
    - PrototypeProviderTest 생성
        - 의존관계를 외부에서 주입(DI) 받는게 아니라 이렇게 직접 필요한 의존관계를 찾는 것을 Dependency Lookup (DL) 의존관계 조회(탐색)이라 함
    - 스프링의 애플리케이션 컨텍스트 전체를 주입받게 되면, 스프링 컨테이너에 종속적인 코드가 되고, 단위 테스트도 어려워짐

2. ObjectFactory, ObjectProvider
    - ObjectProvider는 ObjectFactory의 기능 + 편의 기능 추가한 구현체

* 정리
    - 프로토타입 빈을 언제 사용할까? 매번 사용할 때 마다 의존관계 주입이 완료된 새로운 객체가 필요하면 사용하면 된다. 
    - 실무에서는 싱글톤 빈으로 대부분의 문제를 해결할 수 있기 때문에 프로토타입 빈을 직접적으로 사용하는 일은 매우 드물다.
    - ObjectProvider , JSR330 Provider 등은 프로토타입 뿐만 아니라 DL이 필요한 경우는 언제든지 사용할 수 있다.

### 웹 스코프

* 특징
    - 웹 스코프는 웹 환경에서만 동작
    - 프로토타입과 다르게 스프링이 해당 스코프의 종료시점까지 관리 ->  따라서 종료 메서드가 호출됨

* 종류
    - equest: HTTP 요청 하나가 들어오고 나갈 때 까지 유지되는 스코프, 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고, 관리된다.
    - session: HTTP Session과 동일한 생명주기를 가지는 스코프
    - application: 서블릿 컨텍스트( ServletContext )와 동일한 생명주기를 가지는 스코프
    - websocket: 웹 소켓과 동일한 생명주기를 가지는 스코프

### request 스코프 예제 만들기

- 웹 환경 추가
    - 웹 스코프는 웹 환경에서만 동작하므로, build.gradle에 라이브러리 추가
        - spring-boot-starter-web 라이브러리를 추가하면 스프링 부트는 내장 톰켓 서버를 활용해서 웹 서버와 스프링을 함께 실행시킴

* 참고
    - 스프링 부트는 웹 라이브러리가 없으면 우리가 지금까지 학습한 AnnotationConfigApplicationContext 을 기반으로 애플리케이션을 구동함
    - 웹 라이브러리가 추가되면 웹과 관련된 추가 설정과 환경들이 필요하므로 AnnotationConfigServletWebServerApplicationContext 를 기반으로 애플리케이션을 구동함

* request 스코프 예제 개발
    - 동시에 여러 HTTP 요청이 오면 정확히 어떤 요청이 남긴 로그인지 구분하기 어렵다. -> request 스코프 사용해 구분
    - MyLogger, LogDemoController, LogDemoService 생성 -> 테스트
        - 결과: 애플리케이션 실행 시점에 오류 발생
            - -> 스프링 애플리케이션을 실행하는 시점에 싱글톤 빈은 생성해서 주입이 가능하지만, request 스코프 빈은 아직 생성되지 않음. 이 빈은 실제 고객의 요청이 와야 생성할 수 있기 때문

### 스코프와 Provider

- 해결방안은 앞서 배운 Provider를 사용하는 것
    - ObjectProvider 덕분에 ObjectProvider.getObject() 를 호출하는 시점까지 request scope 빈의 생성을 지연할 수 있음
    - ObjectProvider.getObject() 를 호출하시는 시점에는 HTTP 요청이 진행중이므로 request scope 빈의 생성이 정상 처리됨
    - ObjectProvider.getObject() 를 LogDemoController , LogDemoService 에서 각각 한번씩 따로 호출해도 같은 HTTP 요청이면 같은 스프링 빈이 반환됨 -> 구분 어려움

### 스코프와 프록시

- 프록시 방식으로 해결
    - MyLogger @Scope 애노테이션에 proxyMode = ScopedProxyMode.TARGET_CLASS  추가
        - 이렇게 하면 MyLogger의 가짜 프록시 클래스를 만들어두고 HTTP request와 상관 없이 가짜 프록시 클래스를 다른 빈에 미리 주입해 둘 수 있음

    - 나머지 코드를 Provider 사용 이전으로 돌리기
    
- -> 결과: 정상 동작

* 웹 스코프와 프록시 동작 원리
    - CGLIB라는 라이브러리로 내 클래스를 상속 받은 가짜 프록시 객체를 만들어서 주입
    - 우리가 등록한 순수한 MyLogger 클래스가 아니라 MyLogger$ $EnhancerBySpringCGLIB 이라는 클래스로 만들어진 객체가 대신 등록됨 -> 스프링 컨테이너에 "myLogger"라는 이름으로 이 가짜 프록시 객체를 등록
    - 의존관계 주입도 이 가짜 프록시 객체가 주입됨
    - 가짜 프록시 객체는 실제 요청이 오면 그때 내부에서 실제 빈을 요청하는 위임 로직이 들어있음

* 정리
    - 프록시 객체 덕분에 클라이언트는 싱글톤 빈을 사용하듯이 편리하게 request scope를 사용할 수 있음
    - 사실 Provider를 사용하든, 프록시를 사용하든 핵심 아이디어는 진짜 객체 조회를 꼭 필요한 시점까지 지연처리 한다는 점
    - 단지 애노테이션 설정 변경만으로 원본 객체를 프록시 객체로 대체할 수 있음 -> 다형성과 DI 컨테이너가 가진 큰 강점
    - 웹 스코프가 아니어도 프록시는 사용할 수 있음
    - ****싱글톤을 사용하는 것 같지만, 결국 다르게 동작하기 때문에 주의해서 사용해야 함 -> 특별한 scope는 꼭 필요한 곳에만 최소화해서 사용할 것*
