# Chapter05 - 컴퓨터 아키텍처와 운영체제 - 컴퓨터는 어떻게 프로그램과 메모리를 조직적으로 관리할까

    - 컴퓨터 아키텍처 : 컴퓨터의 여러 구성요소를 배치하는 방법

## 가장 기본적인 구조 요소들

    - 가장 흔한 두 가지 컴퓨터 구조

        - 폰 노이만 구조
        - 하버드 구조

        - 두 구조의 차이는 메모리 배열

        - 하버드 구조가 동시에 명령어와 데이터를 가져올 수 있어서 좀 더 빠르지만 두번째 메모리를 처리하기 위한 버스가 더 필요

    - 프로세서 코어

        - 위의 두 구조는 모두 CPU가 하나 뿐

        - 멀티프로세서 시스템은 단일 CPU보다 훨씬 더 좋은 성능을 얻어내기 위한 방법이지만 여러 CPU를 활용할 수 있도록 병렬화 하는 문제는 쉽지 않음

        - 반도체 회로 크기가 줄어들면서 비용도 낮아졌고 이로 인해 더 나은 성능을 달성
            -> 전력 장벽에 부딪힘 (열로 인해 회로를 이루는 물질의 녹는점 이상으로 온도가 올라가는 것)
        
    - 마이크로프로세서와 마이크로컴퓨터

        - 마이크로프로세서 : 메모리와 I/O가 프로세서 코어와 같은 패키지에 들어있지 않은 프로세서
            - 보통 큰 시스템에 들어가는 부품

        - 마이크로컴퓨터 :  모든 요소를 한 칩 안에 패키징한 프로세서 (= 마이크로컨트롤러)
            - 단일 칩으로 된 작은 컴퓨터 

        * SoC (System On a Chip)
            - 더 복잡한 마이크로컴퓨터
            - 상대적으로 간단한 온칩I/O를 제공하는 대신 SoC에는 WiFi 회로 등의 더 복잡한 장치가 들어있음
            - ex) 맥북

## 프로시저, 서브루틴, 함수

    - 함수(=프로시저, = 서브루틴)는 코드를 재사용하는 주요 수단

    - 세 용어는 동일하지만 프로그래밍 언어에 따라 부르는 이름이 다르다

    - 함수를 실행하고 다시 원래 자리로 돌아오기 위해서는 어디서 함수로 들어갔는지를 기억해야 하며, 함수로 들어간 위치는 프로그램 카운터의 값이다

    - 위 과정은 상당히 많은 작업이 필요하기ㄷ 때문에 대부분의 기계는 이런 과정을 돕는 명령어를 제공
        - ex) ARM 프로세서에서는 링크 레지스터를 사용한 분기 명령어(함수로 호출하는 명령어 + 현재 명령어의 다음 위치를 저장하는 명령어)

## 스택 

    - 함수가 자기 자신을 호출 -> 재귀

    - 트리구조 (P200-그림5-4 참고)
        - 화살표가 더 이상 뻗어나가지 않는 부분 : 잎 노드

        - 예시에서는 각 노드에서 가지가 4개 뻗어나가므로 쿼드트리라고 부르며, 쿼드트리는 공간 데이터 구조에 속함

        - 깊이 우선 순회 : 트리 아래로 내려갈 수 있으면 내려가고, 더 이상 아래로 내려갈 화살표가 없는 경우에만 옆에 있는 화살표로 넘어가는 방식
        - 너비 우선 순회 : 옆에 있는 화살표를 먼저 방문하고 그 후 아래쪽으로 가는 화살표를 방문하는 방식

        - 트리에서 한 수준을 내려갈 때마다 돌아올 위치를 기억해야하며, 원래 위치로 돌아오고 나면 저장했던 위치는 더 이상 필요하지 않음

        - 스택 : 메모리를 쌓아올린 구조 (LIFO ; Last In First Out)

        - 함수 호출에서 돌아올 떄는 스택 맨 위의 메모리를 보고 반환 주소를 결정한 다음, 메모리를 제거

        - 푸쉬(push) : 추가 / 팝(pop) : 제거

        - 스택에 더 이상 공간이 없으면 Stack Overflow / 스택이 비어있는데 값을 가져오려고 하는 경우 Stack Underflow

        - 스택은 단지 반환 주소만 저장하기 위한 장소가 아니라 함수 호출이 서로 독립적이게 도와줌

        - 스택 프레임 : 함수가 호출될 떄마다 스택에 저장되는 데이터의 모음

## 인터럽트

    - 실행중인 프로그램을 잠깐 중단시켜서 주의를 기울여야 하는 외부의 요소에 대응할 수 있게 하는 방법

    - 요즘 쓰이는 프로세서 대부분은 인터럽트 시스템이 들어감

    - 인터럽트 시스템은 적절한 신호가 들어오면 CPU 실행을 잠깐 중단시킬 수 있는 핀이나 전기 연결을 포함 (핀은 칩에 연결된 전기적 접점)

    - 작동 방식

        1. 인터럽트 요청을 생성

        2. 현재 실행 중인 명령어를 끝까지 실행한 후 프로세서는 현재 실행 중인 프로그램을 잠시 중단시키고 인터럽트 핸들러라는 전혀 다른 프로그램을 실행

        3. 인터럽트 핸들러가 작업을 다 마치면 원래 실행 중이던 프로그램의 중단된 위치부터 다시 실행

    - 고려해야할 요소

        1. 응답시간
            - 인터럽트 처리를 정해진 시간 안에 끝내야 함

        2. 인터럽트를 서비스하고 나중에 다시 원래대로 돌아오기 위해서는 현재 상태를 저장할 방법 필요
            - 중단된 프로그램이 사용하던 레지스터 값을 복구 해줘야 함
            - 인터럽트 시스템은 서비스 후 돌아올 프로그램 위치를 스택에 저장
            - 인터럽트 핸들러는 자신이 덮어쓸 레지스터를 모두 저장
            - 인터럽트 벡터 : CPU가 지원하는 각 인터럽트에 대한 핸들러 주소를 지정, 메모리 위치를 가리키는 포인터

    - 전형적인 경우 여러 가지 종류의 특별한 인터럽트 제어가 가능

        - 마스크 : 인터럽트를 중단시킬 수 있는 장치

        - 타이머 : 인터럽트를 발생시킬 수 있는 장치

## 상대 주소 지정

    - 여러 프로그램을 동시에 실행하려면 각 프로그램을 서로 전환시켜 줄 수 있는 관리자 프로그램이 필요 => 운영체제 또는 운영체제 커널

    - OS : 시스템 프로그램
    - OS가 관리하는 프로그램 : 사용자 프로그램 or 프로세스

    - 시분할 : 프로세서의 실행 시간을 조절하는 스케줄링 기법
        - 시간을 정해진 간격으로 나누고, 정해진 시간 간격 동안 사용자 프로그램을 실행

    - 사용자 프로그램 상태 or 문맥(컨텍스트) : 레지스터의 상태와 프로그램이 사용 중인 메모리의 상태

    - 절대 주소 지정은 명령어 주소가 특정 메모리 주소를 가리킴
        - 1000번지에서 실행되도록 만들어진 프로그램을 2000번지에서 읽으면 실행x

    - 위의 문제를 해결하기 위해 인덱스 레지스터를 추가
        - 인덱스 레지스터의 값을 명령어에 들어 있는 주소와 더해서 유효 주소를 계산

    - 또 다른 방법은 상대 주소 지정
        - 명령어에 들어 있는 주소를 0부터 시작하는 위치로 해석하지 않고, 명령어의 주소를 기준으로 하는 상대적인 주소로 해석

        - 요즘 프로그래밍 언어 도구들은 모두 이런 계산을 알아서 해줌

        - 상대 주소 지정을 사용하면 프로그램을 메모리의 원하는 위치로 자유롭게 재배치 가능

## 메모리 관리 장치

    - MMU = 메모리 관리 장치

    - MMU가 들어 있는 시스템은 가상 주소와 물리 주소를 구분

    - 프로그램은 가상 주소를 사용해 작성되고, MMU는 가상 주소를 물리 주소로 변환

    - MMU는 가상 메모리 주소를 두 부분으로 나눔
        - 주소의 하위(LSB 쪽)부분은 물리적 주소 범위와 같고 상위(MSB 쪽)부분은 페이지 테이블이라는 RAM 영역을 통해 주소를 변환

    - 현대적 프로세서의 MMU는 페이지 테이블 크기가 정해져 있음

    - 전체 페이지 테이블 항목은 주 메모리에 저장되거나 주 메모리가 부족한 경우 디스크에 저장

    - MMU는 페이지 테이블 항목 중 일부를 필요할 때만 자신의 페이지 테이블로 읽어 들인다

    - 일부 MMU 설계는 페이지 테이블에 제어 비트를 추가 제공
        - ex) 실행 불가 비트
              읽기 전용으로 만드는 비트
    
    - MMU로 인해 폰 노이만 구조와 하버드 구조의 구분이 의미 없어짐

## 가상 메모리

    - OS는 희소한 하드웨어 자원을 사용하려고 경합하는 프로그램들 사이의 자원 분배를 관리

    - 메모리도 OS가 관리하는 자원이며, OS는 MMU를 사용해 사용자 프로그램에게 가상 메모리를 제공

    - 요청받은 메모리가 사용가능한 메모리보다 크다면 OS는 현재 필요하지 않은 메모리 페이지를 더 느리지만 용량이 큰 대용량 저장장치인 디스크로 옮김 (=스왑 아웃)

    - 스왑 아웃한 페이지에 프로그램이 접근하면 운영체제는 필요한 메모리 공간을 확보하고 요청받은 페이지를 다시 메모리로 불러들인다 (=스왑 인)

    - 스왑 아웃, 스왑 인 으로 페이지를 처리하는 것 => 요구불 페이징

## 시스템 공간과 사용자 공간

    - 사용자 프로그램이 MMU의 설정을 마음대로 바꿀 수 있다면 MMU가 프로그램을 서로 격리 못시킴

    - CPU는 트랩이나 시스템 콜 처럼 특별한 명령어를 통해 사용자 모드에서 실행 중인 프로그램이 시스템 모드 프로그램(=OS)에게 요청을 보낼 수 있음
        
        - 이런 방식의 장점

            1. 사용자 프로그램으로부터 운영체제를 보호하고, 사용자 프로그램을 다른 사용자 프로그램으로부터 보호

            2. 사용자 프로그램이 MMU 등의 몇몇 요소에 손을 댈 수 없기 때문에 운영체제가 프로그램에 대한 자원 할당을 전적으로 제어

## 메모리 계층과 성능

    - CPU에 비해 메모리의 작업 속도가 느린 문제를 해결하기 위해 캐시라는 하드웨어를 CPU에 추가
    
    * 캐시 => 메모리보다 작지만 빠르고 프로세서와 같은 속도로 작동

    - CPU 메모리 컨트롤러 하드웨어는 메모리에서 연속된 열에 있는 데이터를 한꺼번에 가져오면 캐시 실패가 일어나도 CPU는 고속 메모리 접근 모드가 가능하기 때문에 유리

    * 캐시 실패 => CPU가 캐시에서 어떤 내용을 찾았는데 캐시에 그 데이터가 없어서 메모리를 읽어야 하는 경우를 뜻함

    - 캐시 메모리에는 몇 가지 계층이 존재
        - 모든 캐시가 같은 칩 안에 존재하는 경우에도 CPU에서 멀어질수록 캐시는 더 느려지고 더 커짐
        -L1, L2, L3 가 있음

    * 메모리 계층 (오른쪽으로 갈수록 느리고 쌈)

        CPU -> 레지스터 -> L1 캐시 -> L2 캐시 -> L3 캐시 -> 주 메모리 -> 대량 저장장치

    - 데이터를 기록할 때 캐시에 데이터가 먼저 기록

    - 기록된 데이터를 사용해야 하는 다른 코어나 프로세서가 해당 메모리 위치의 데이터 변경을 감지하는 방법 -> 라이트 스루

    - 라이트 스루 : 데이터를 캐시에 기록하는 동시에 메모리에도 기록 but, 캐시를 사용하는 장점을 대부분 없앰

## 코프로세서

    - 프로세서 코어는 복잡한 회로라서, 몇 가지 연산을 코프로세서라는 단순한 회로에 위임하면서 프로세서 코어가 일반적인 연산에 활용할 수 있는 공간을 더 확보

    - 일부 코프로세서는 다른 일은 처리하지 않고 데이터 복사만 담당 -> 직접 메모리 접근

## 메모리 상의 데이터 배치

    - 정적(static) : 프로그램을 작성할 때 얼마나 많은 메모리가 필요한지 알고 있다는 의미

    - 동적 (dynamic) : 프로그램을 실행하기 전에는 크기를 알 수 없다는 의미

    - 동적 데이터는 주로 정적 데이터가 차지하는 영역의 바로 위 영역에 쌓임 (= 힙)

    - 더 많은 데이터를 저장해야 할 경우, 스택은 아래로 자라나는 반면, 힙은 위로 자람

## 프로그램 실행

    - 라이브러리 : 관련 함수의 모음

    - 프로그램을 여러 파일로 나눠놓을 경우, 여러 사람이 한 프로그램의 여러 부분을 동시에 개발할 수 있다는 장점이 존재

    - 프로그램을 여러 조각으로 나누면 이 모든 조각을 하나로 엮거나 연결할 방법이 필요 -> 링커라는 프로그램을 사용해 여러 조각을 하나로 연결

    - 정적 링크 : 라이브러리를 단지 프로그램의 나머지 부분과 직접 연결 

    - 동적 링크 : 공유 라이브러리를 사용 (메모리 절약)

    - 프로그램에는 진입점(첫 번째 명령어가 위치한 주소)이 존재 but, 실제 프로그램이 실행될 떼 가장 먼저 실행되는 진입점에 있는 명령어가 아님

    - 프로그램을 이루는 모든 부분이 합쳐져서 실행파일을 이룰 때 런타임 라이브러리가 추가 -> 런타임 라이브러리에 있는 명령어가 먼저 실행

    - 런타임 라이브러리는 메모리 설정을 책임짐
        - 스택과 힙 영역을 설정
        - 정적 데이터에 위치한 데이터의 초기값도 설정

## 메모리 전력 소비

    - 데이터를 메모리에서 옮기려면 전력이 소비됨

    - 모바일 장치에서는 전력 소비가 중요 -> 코드를 작성할 때도 염두

