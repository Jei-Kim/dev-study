# Chapter04 - 컴퓨터 내부 구조 - 컴퓨터 하드웨어는 어떻게 구성되는가

    - 컴퓨터 : 전자 부품을 다양하게 조합해 비트를 조작하는 회로

    - 현대적 컴퓨터 = 메모리 + 입출력 + CPU <- 이렇게 세 가지 부분으로 나눌 수 있음

## 메모리

    - 조작할 비트들을 저장할 장소

    - 메모리는 비트를 저장할 수 있는 공간이 빼곡하게 있으며, 그 공간에는 1바이트씩 저장된다

    - 각각의 공간에는 주소가 부여 (주소는 그냥 숫자)

    - 메모리의 기본 단위가 바이트라는 것이 꼭 바이트 단위로만 데이터를 읽어야하는 것은 아님

    - 보통 32비트 컴퓨터는 메모리를 4바이트 덩어리로, 64비트 컴퓨터는 메모리를 8바이트로 구성 => 큰 바이트 단위로 구성할수록 더 많은 양의 데이터를 처리 가능

    - 64비트 컴퓨터의 경우 바이트 주소 8개 or 워드(16비트)주소 4개 or 긴 워드(32비트)주소 2개로 주소를 관리하며 데이터를 읽을때는 한 번에 한 주소에서만 읽을 수 있다

    - 두 주소를 읽어야 하는 경우에는 두 번 왕복 해야했음 -> 현대 컴퓨터에서는 이런 기능을 제외
        -> 이런 경우를 '정렬이 맞지 않는 접근'이라고 부름

    - 메모리를 읽는 방식은 사용되는 프로세서에 따라 달라짐
        - ex) 인텔 프로세서와 모토로라 프로세서가 읽는 방식이 다름

## 입력과 출력

    - 입력과 출력 = I/O

    - I/O 장치 => 컴퓨터의 주변부에 위치하기 때문에 주변장치(peripheral)이라고 불림

    - 과거에는 I/O 처리를 위한 메모리와 일반 메모리를 따로 나눠서 처리 (메모리가 작았기 때문)

    - 현재는 메모리 공간이 많기 때문에 빈 주소의 일부를 I/O 장치에게 할당해줌


## 중앙 처리 장치

    - CPU : 실제 계산을 처리하는 컴퓨터 부품
        - 다른 모든 요소는 CPU를 지원하는 역할

    - 산술 논리 장치

        - CPU의 핵심 부품

        - 산술 계산, 불리언 대수 및 기타 연산을 수행하는 방법을 알고 있는 장치

    - 시프트

        - 왼쪽 시프트 : 어떤 숫자의 모든 비트를 왼쪽으로 1비트씩 옮기고, 맨 왼쪽 비트는 버리고, 비게 되는 가장 오른쪽 비트에 0을 넣는다
            - 어떤 수를 1비트 왼쪽으로 시프트 = 어떤 수에 2를 곱한 것

        - 오른쪽 시프트 : 어떤 숫자의 모든 비트를 오른쪽으로 1비트씩 옮기고, 맨 오른쪽 비트는 버리고, 비게 되는 가장 왼쪽 비트에 0을 넣는다
            - 어떤 수를 1비트 오른쪽으로 시프트 = 어떤 수를 2로 나눈 것

    - 실행 장치

        - 실행장치 = 제어 장치

        - ALU 자체로는 유용하지 않음

        - 실행 장치는 메모리의 정해진 장소에서 명령코드와 피연산자들을 가져와서 ALU에게 어떤 연산을 수행할 지 알려주고, 결과를 메모리에 돌려준다

        - 실행장치는 명령어를 통해 일을 함 -> 명령어는 메모리에 존재 => 이런 방식을 프로그램 저장 방식 컴퓨터
            
        - 명령어 : 컴퓨터에게 어떤 일을 할지 알려주는 비트 패턴
            - 공통 표준이 없어서 다른 제조사면 명령어도 다름!

        - 명령어를 가져와야 하는 위치는 '프로그램 카운터'를 사용

            - 프로그램 카운터

                - 레지스터의 일종이며, 메모리와 별도의 특별한 곳에 위치

                - 프로그램 카운터에는 메모리 주소가 들어있어서 메모리 위치를 가리킴

                - 프로그램 카운터의 값을 바꾸는 명령어가 존재

                - 위의 명령어를 실행하는 경우가 아니라면 명령어를 수행한 뒤에는 다음 명령어를 메모리의 다음 위치에서 가져올 수 있도록 프로그램 카운터가 증가된다


## 명령어 집합

    - 컴퓨터가 보물찾기를 하는 중에 메모리에서 찾는 쪽지를 명령어라고 부름

    -명령어

        - 어떤 종류의 명령어를 CPU에서 찾을 수 있는지 살펴보고, 명령어에 어떤 비트 패턴을 선택해야 할지 알기 위한 방법

            - 명령어를 명령코드, 두 피 연산자, 결과 이럻게 네 가지 필드로 나누는 방식

                - 주소가 작을수록, 쓸모 있는 메모리를 가리키기 어렵다는 단점이 있지만 최신 컴퓨터는 기가바이트 이상 메모리를 쓸 수 있다

            - DRAM 주소 지정 기법

                - 주소 확장 레지스터를 두고 별도의 명령어를 사용해 상위 주소를 지정

                - 값을 설정하려면 오래 걸리고, 이런 접근 방식을 사용해 메모리 영역을 모두 지정하려면 여러 번 레지스터를 설정해야 한다는 단점 존재

            - 3주소 명령어

                - 세 가지 메모리 위치를 한꺼번에 지정하는 메모리 주소 접근을 사용

                - 세 메모리 블록들은 각기 다른 장치에 존재

                - 이런 형태의 장치에서 명령을 수행하는 회로는 아주 복잡해짐

                - 레지스터에 다른 메모리를 추가 
                    -> 이러한 레지스터를 누산기라고 함 

                - 누산기를 통해 해결 <- 직접 주소 지정

    - 주소 지정 모드

        - 직접 주소 지정 - 누산기를 활용하여 주소를 가리키는 방식

        - 간접 주소 지정 - CPU가 명령어에 들어 있는 값을 피연산자 주소로 해석하지 않고, 피연산자 주소를 얻을 수 있는 메모리 위치를 가리키는 주소로 사용하는 방식

        - 위 두가지 방식으로도 메모리를 다루기 충분 But, 상수를 지정해야 할 때도 있음

        - 이를 위해 즉시 주소 지정 모드라는 방식을 추가할 수 있음

             - 즉시 주소 지정 모드 : 주소에 해당하는 비트를 그냥 값으로 간주
        
        - 직접 주소 지정을 즉시 주소 지정보다 느림 <- 메모리에 두 번 접근하기 때문

        - 간접 주소 지정은 세 번 접근

    - 조건 코드 명령어

        - 조건 코드를 원하는 값으로 설정하거나, 조건 코드의 값을 살펴볼 수 있는 방법이 필요

        - 조건 코드 레지스터의 값을 누산기로 복사하는 cca라는 명령어와 누산기의 값을 조건 코드 레지스터에 복사하는 acc라는 명령어를 추가할 수 있음

    - 분기 명령어

        - 위 명령어 중 일부를 선택적으로 실행할 수 있는 프로그램 -> 분기 명령어 (프로그램 카운터의 값을 변결할 수 있는 명령어)

        - 프로그램 카운터의 내용을 명시적으로 바꿀 필요 -> 두 가지 명령어 존재 (pca : 현재 프로그램 카운터 값을 누산기에 복사, apc : 누산기의 값을 프로그램 카운터에 복사)

    - 최종 명령어 집합 구성

        - 모드 + 명령코드 + 주소 로 구성

        - 위에 적은 주소 지정 모드 선택을 위해서는 2비트 필요

        - 이를 통해 프로그램을 작성해 컴퓨터에게 지시 가능 (피보나치 수열 계산을 통해)

## 마지막 설계

    - 명령어 레지스터

        - 명령어 실행 순서

            1. 메모리에서 명령어를 가져옴 (=fetch; 페치)
                - 페치한 명령어에 편하게 접근할 수 있도록 저장할 다른 위치 필요
                    -> CPU에 명령어 레지스터를 추가해서 현재 실행 중인 명령어를 저장

                - 프로그램 카운터 -> 메모리 -> 명령어 레지스터

    - 데이터 경로와 제어 신호

        - P185 - 그림 4-22 참고

        - 간접 주소 레지스터 : 간접 주소 지정을 사용할 때 메모리에서 읽어온 주소를 저장
   
    - 데이터 흐름 제어

        - 명령어를 처리하려면 페치를 해야함

            - address source 라는 프로그램 카운터를 선택

            - 메모리를 동작

            - 명령어 레지스터를 동작시켜야함

        - 페치와 실행에는 여러 단계가 필요 -> 각 단계를 추적할 카운터가 핑ㄹ요

        - 이 카운터의 내용과 명령어의 멸령 코드와 모드 부분이 제어 신호를 결정

        - 가장 복잡한 연산의 경우 3단계가 필요하기 때문에 카운터는 2비트 카운터여야 함

        - 랜덤논리 : 일반적인 구조가 아닌 복잡한 구조를 구현하는 경우, 정해진 개수의 입력이 있지만 출력에는 어떤 규칙성이 없을 경우의 구조
            -> 랜덤논리가 아닌 적당한 크기의 메모리로도 구현 가능 (P.188 그림 4-24 참고)

        - 이런 식으로 구현하는 방법 = '마이크로 코드를 썼다' 라고 표현, 메모리의 내용이 마이크로 코드

            - 마이크로코드로 메모리로는 ROM이 적합

            - 일반 사용자가 마이크로코드를 변경하는 것 허용x
                -> 사용자가 명령어에 의존성이 생기면 생산자가 하드웨어를 변경하기 어려워지기 때문

## RISC와 CISC 명령어 집합

    - 명령어가 많아질수록, 컴퓨터 제어 회로도 복잡해짐 but, 명령어 중 상당수는 거의 쓰이지 않음

    - 프로그램에서 많이 쓰이는 명령어만을 포함하는 기계를 설계 -> 이러한 기계는 복잡한 명령어를 단순한 명령어를 조합해서 처리 => RISC 기계
        -> 이와 대조적으로 기존 설계 방식으로 만든 컴퓨터 => CISC 기계

    - RISC의 특징

        - 적재-저장 구조 : 메모리와 레지스터를 오가는 명령어들과 레지스터 간 명령어로만 이루어진 아키텍쳐
        
        - 최근 RISC는 오래전의 CISC 보다 훨씬 더 복잡함

    - CISC

        - ex) 디지털 이큅먼트 사의 PDP-11
            - ALU 역할을 할 수 있는 범용 레지스터 8개
            - 자동증가 및 자동감소 주소 지정 모드 지원 -> 레지스터를 사용하기 전이나 후에 레지스터에 들어 있는 값을 감소시키거나 증가시켜주는 모드
                -> 이러한 모드는 PDP-11 메모리 복사 프로그램 (P191 표 4-5)과 같은 프로그램을 효율적으로 작성 가능

            - 자동증가와 자동감소 기능은 C언어의 포인터와 잘 ㅇ우러짐

            - C 뿐만 아니라 C++, 자바, 자바스크립트 등 많은 언어에 영향을 미침


## GPU

    - 그래픽 처리 장치

    - 그래픽 처리는 아주 특화된 작업이라 CPU가 제공하는 모든 기능이 필요 x

    - GPU의 기능
        1. 간단한 처리 장치가 많이 들어 있음

        2. 메모리 버스의 폭이 CPU보다 넓음