# Chapter03 - 메모리와 디스크의 핵심 : 순차 논리

 - 조합 논리는 입력의 현재 상태만 다룸, 순차 논리는 입력의 현재 상태와 과거 상태를 함께 고려

## 시간 표현과 상태 기억

    - 발진자

        - 인버터의 출력을 입력에 연결할 경우 이런 식의 연결을 피드백 이라고 한다

        - 출력이 0과 1 사이를 진동 (진동하는 속도는 전파 지연에 따라 결정)

        - 적은 비용으로 효율적으로 만드는 방법은 크리스탈을 활용

    - 클록

        - 발진자는 컴퓨터에 클록을 제공

        - 회로의 페이스를 결정

        - 회로의 최대 클록 속도나 가장 빠른 템포는 회로의 전파 지연 시간에 의해 결정

    - 래치

        - 정보를 1비트 기억하는 방법

        - 회로 in이 1이 되면 out도 1이 되며, in이 다시 0이 되더라도 out은 1로 유지된다 (즉, 자신의 과거 상태를 기억하므로 추가적인 작업 또한 필요)

    - 게이트가 있는 래치

        - 어느 시점에 무언가를 기억하게 해줌

        - 문제점 : 참인 상태에서는 변화가 그대로 출력 -> 잘못된 데이터 변경이 생길 가능성이 높아짐

    - 플립플롭

        - 예지에 의해 데이터 변화가 촉발되는 래치

        - 데이터 변경으로 인해 잘못된 결과가 생길 수 있는 가능성을 최소화

        - 방지하기 위한 방법 -> 예지 : 논리 수준이 특정 값에 머무는 동안 데이터를 잡아내지 않고 논리 수준이 한 수준에서 다른 수준으로 전이되는 중간에 데이터를 잡아내는 것

    - 카운터

        - 플리플롭을 응용한 회로

        - 비동기 카운터 : 각 비트의 상태가 다른 비트의 상태 변화에 약간의 시차를 두고 바뀌는 회로

        - 동기적 카운터 : 상태 변경이 동시에 일어남

    - 레지스터

        - 클록을 공유하는 여러 D 플리플롭을 한 패키지에 넣은 것

## 메모리 조직과 주소 지정

    - 훨씬 더 많은 정보를 저장해야 한다면 레지스터를 많이 쌓아두는 것부터 시작할 수 있다

        => 어떤 레지스터를 사용해야 하는지 어떻게 지정?

            => 해결방안 : 각 레지스터에 번호를 부여 (번호 = 주소) -> 실렉터를 통해 지정한 주소에 해당하는 레지스터의 출력, 시스템에서 여러 메모리 컴포넌트의 출력을 한 출력으로 연결해야 할 경우 '트라이스테이트' 출력이라는 또 다른 기본 요소가 필요

            - 위 요소를 다 합치면 메모리 컴포넌트가 만들어짐

    * 메모리 컴포넌트

        - 연결 지점이 많지만 메로미를 동시에 읽고 쓸 필요가없으므로 연결을 줄이고, 입출력 연결을 합치는 등을 통해 연결을 줄임

        - 메모리 칩에는 주소 버스와 데이터 버스가 존재 (버스 : 비트를 이동시키는 대량 교통수단)

        - CPU에서 주소를 행과 열의 두 덩어리로 나누고 메모리 내부 위치는 열과 행을 조합해 지정된다
            
        - 행과 열을 멀티플렉싱하면 주소 라인의 수를 반으로 줄일 수 있다

## 임의 접근 메모리

    - 임의 접근 메모리 = 램

    - 메모리 위치 중 원하는 곳은 어디든 원하는 순서로 쓰거나 읽을 수 있다

    - 정적RAM(SRAM) : 빠르지만 메모리가 작음

    - 동적램(DRAM) : 집적도가 높기 때문에 큰 메모리 칩에 사용

    - SRAM, DRAM 둘 다 휘발성 메모리 (전원이 꺼지면 데이터가 사라짐)

## 읽기 전용 메모리

    - 읽기 전용 메모리 = ROM

        - 한번만 쓸 수 있지만 여러 번 읽을 수 있음

    - EPROM : 자외선을 통해 내용을 지울 수 있는 롬

    - EEROM : 전기로 지울 수 있는 EPROM

        - 내부 데이터를 아무 순서로나 쓰고 읽을 수 있기 때문에 기술적으로는 RAM

        - 하지만 데이터를 쓰는 데 시간이 오래 걸리고 RAM보다 비싸기 때문에 ROM을 대신하는 목적으로 쓰임

## 블록장치

    - 디스크 드라이브 = 대량 저장장치

    - 판에 비트를 저장하고 판이 돌면서 디스크 헤드가 데이터를 꺼낸다

    - 문제점 
        1. 다른 유형의 메모리에 비해 상대적으로 느림
        2. 회전축의 마찰을 줄여주는 베어링의 마모 등 기계 부품이 시간이 지나면서 낡아짐

    - 하지만 DRAM 등과 달리 주소나 데이터 연결을 위한 공간이 필요 없음

    - 블록 단위로 주소를 지정해 읽음 (블록 = 섹터, 디스크에서 읽고 쓰기가 가능한 가장 작은 단위)

    - 비트 밀도는 각 원판의 바깥쪽보다 안쪽이 더 높다

        - 최신 디스크들은 이 문제를 방사상 영역으로 구분해 해결
            -> 외부 영역에 더 많은 섹터가 들어감

## 플래시 메모리와 SSD

    - 플래시 메모리

        - 가장 최근 나타난 EEPROM 유형의 매체

        - DRAM과 마찬가지로 버켓에 전자를 담는 방식

        - But, 플래시 메모리는 DRAM보다 더 크고 잘 만들어져 있어서 전자가 새지 않음

        - RAM처럼 원하는 위치를 마음대로 읽을 수 있음

        - 즉, 읽을 때는 임의접근 장치이고, 쓸 때는 블록 접근 장치이다.

    - SSD

        - 고체 상태 드라이브

        - 디스크 드라이브 모양의 패키지에 넣은 플래시 메모리와 같음

## 오류 감지와 정정

    - 패리티를 사용하면 단 1비트가 데이터가 잘못된 경우를 감지 가능

    - 더 복잡한 방법으로 해밍 코드 등이 있음

    - 이러한 회로를 내장한 오류검사와 정정 메모리칩도 존재 (소비자용 장치가 아닌 큰 데이터 센터 등에 쓰임)

    - 체크섬, 순환 중복 검사 등도 존재

## 하드웨어와 소프트웨어 비교

    - 펌웨어 : ROM에 담긴 소프트웨어를 가리키는 용어였지만 요즘 대부분의 펌웨어는 플래시 메모리 상에 존재하거나 심지어 RAM 상태에도 존재

     -초반 모든 칩 설계는 완전한 커스텀 설계(설계자가 직접 만든 설계)였음

     - 게이트 배열 : 미리 설계된 구성요소가 존재하고 금속 계층만 커스텀화

     - 게이트 배열도 메모리와 마찬가지로 PROM이나 EEPROM에 해당하는 직접 프로그래밍 할 수 있는 칩으로 변화

     - 현대적 FPGA(Field-Programmable Gate Array ; 현장에서 프로그램 가능한 게이트 배열) : 플래시 메모리에 해당하는 논리 칩

    - FPGA를 사용하면 소프트웨어로 로직을 지우고 다시 프로그래밍 가능
    

