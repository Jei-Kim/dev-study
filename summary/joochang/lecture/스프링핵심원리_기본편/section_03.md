# 스프링 핵심원리_기본편

## 스프링 핵심 원리 이해2 - 객체 지향 원리 적용

1. 새로운 할인 정책 개발 
   (기존 정액 할인 정책 ---> 정률 할인 정책으로 변경)

    - 정률 할인 정책 구현체 생성

    - 테스트 작성 및 완료

2. 새로운 할인 정책 적용과 문제점

    - 할인 정책 변경 시, 클라이언트인 OrderServiceImpl 코드를 고쳐야 함

    * 문제점 

        - 역할과 구현을 충실하게 분리 -> Ok

        - 다형성도 활용하고, 인터페이스와 구현 객체를 분리 -> Ok

        - OCP, DIP 같은 객체지향 설계 원칙을 충실히 준수 -> No
            -> 주문서비스 클라이언트(OrderServiceImple)는 인터페이스에 의존하면서, 구체 클래스에도 의존! (DIP 위반) 
               그래서 구체 클래스를 변경하는 순간, 클라이언트의 소스 코드도 함께 변경해야 한다! (OCP 위반)

    * 해결방안

        - DIP 위반 해결 방안

            - 인터페이스에만 의존하도록 설계 변경

            - private final DiscountPolicy discountPolicy = new RateDiscountPolicy();
                -> private DiscountPolicy discountPolicy;

                => 메모리만 존재하고 실제 참조하고 있지 않으므로 NPE (NullPointerException) 발생

                    -> 누군가가 클라이언트에 구현체를 대신 생성하고 주입해주어야 한다.

3. 관심사의 분리

    - 애플리케이션을 하나의 공연이라고 보면, 각각의 인터페이스를 배역(배우의 역할) 이라고 생각하자

    - 이전에는 마치 로미오 역할을 하는 배우가 줄리엣 역할을 하는 배우를 직접 초빙하는 것과 같다.

    - 로미오 역할을 하는 배우는 공연도 해야하고 동시에 줄리엣 역할을 하는 배우도 초빙해야 하는 다양한 책임을 가지고 있다!

    * 관심사를 분리하자
     
        - 배우는 배역을 수행하는 것에만 집중해야 한다

        - 공연을 구성하고 배우를 섭외하는 별도의 공연 기획자가 따로 필요하다.

        - 공연 기획자를 만들고, 배우와 공연 기획자의 책임을 확실히 분리하자

    - App
